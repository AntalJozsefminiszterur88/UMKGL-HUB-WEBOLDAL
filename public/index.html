<!DOCTYPE html>
<html lang="hu">
  <head>
    <meta charset="UTF-8" />
    <title>UMKGL HUB</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="program_icons/oldal_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;700&family=Roboto+Condensed:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css"
      referrerpolicy="no-referrer"
    />
    <link rel="stylesheet" href="HOI4-Porgonc/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"
      referrerpolicy="no-referrer"
    ></script>
    <style>
      .avatar-cropper-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.65);
        z-index: 1200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
      }

      .avatar-cropper-modal.open {
        opacity: 1;
        pointer-events: auto;
      }

      .avatar-cropper-dialog {
        background: #2b2d31;
        border-radius: 16px;
        width: min(780px, 94vw);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.05);
        overflow: hidden;
        color: #e4e6eb;
      }

      .avatar-cropper-header {
        padding: 1.1rem 1.4rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        background: #36393f;
      }

      .avatar-cropper-header h3 {
        margin: 0;
        font-size: 1.15rem;
        letter-spacing: 0.01em;
      }

      .avatar-cropper-body {
        padding: 1.4rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        background: #2f3136;
      }

      .avatar-cropper-canvas {
        background: #1f2125;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        padding: 0.75rem;
        display: grid;
        place-items: center;
        min-height: 360px;
      }

      .avatar-cropper-canvas img {
        max-width: 100%;
        display: block;
      }

      .avatar-zoom-control {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        background: #25272b;
        padding: 0.75rem 1rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .avatar-zoom-control .zoom-icon {
        opacity: 0.8;
        font-size: 0.95rem;
      }

      .avatar-zoom-range {
        flex: 1;
        accent-color: #5865f2;
        height: 6px;
      }

      .avatar-zoom-range::-webkit-slider-runnable-track {
        background: linear-gradient(90deg, #4e5bd5, #5865f2);
        height: 6px;
        border-radius: 999px;
      }

      .avatar-zoom-range::-moz-range-track {
        background: linear-gradient(90deg, #4e5bd5, #5865f2);
        height: 6px;
        border-radius: 999px;
      }

      .avatar-zoom-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid #5865f2;
        margin-top: -6px;
        box-shadow: 0 6px 18px rgba(88, 101, 242, 0.4);
      }

      .avatar-zoom-range::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid #5865f2;
        box-shadow: 0 6px 18px rgba(88, 101, 242, 0.4);
      }

      .avatar-cropper-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        padding: 1rem 1.4rem 1.3rem;
        background: #2b2d31;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
      }

      .cropper-view-box,
      .cropper-face {
        border-radius: 50% !important;
      }

      .cropper-view-box {
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.85);
      }

      .cropper-modal {
        background-color: rgba(0, 0, 0, 0.35);
      }

      #fajlkuldes {
        background: rgba(24, 25, 28, 0.95);
        border-radius: 16px;
        padding: 1.75rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        margin: 0 auto 2rem auto;
        border: 1px solid rgba(255, 255, 255, 0.03);
        max-width: 1400px;
        width: 100%;
      }

      #fajlkuldes h2 {
        margin-bottom: 0.35rem;
      }

      .transfer-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .transfer-subtitle {
        color: rgba(255, 255, 255, 0.65);
        margin: 0;
      }

      .switch-control {
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        background: rgba(114, 137, 218, 0.12);
        border: 1px solid rgba(114, 137, 218, 0.25);
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        color: #e4e6eb;
        font-weight: 600;
      }

      .transfer-status {
        margin: 0.35rem 0 1rem 0;
        color: rgba(255, 255, 255, 0.75);
      }

      .transfer-dashboard {
        display: grid;
        grid-template-columns: minmax(0, 1.8fr) 380px;
        gap: 1.25rem;
        margin-top: 0.75rem;
        align-items: stretch;
      }

      @media (max-width: 1100px) {
        .transfer-dashboard {
          grid-template-columns: 1fr;
        }
      }

      .transfer-radar,
      .transfer-panel {
        background: linear-gradient(145deg, rgba(34, 36, 40, 0.9), rgba(21, 22, 25, 0.9));
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 12px 30px rgba(0, 0, 0, 0.35);
      }

      .transfer-panel__header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.5rem;
      }

      .transfer-panel__header p {
        color: rgba(255, 255, 255, 0.65);
        margin: 0.1rem 0 0 0;
      }

      .transfer-list {
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding-right: 0.35rem;
      }

      .transfer-empty {
        text-align: center;
        color: rgba(255, 255, 255, 0.6);
        padding: 1rem;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        border: 1px dashed rgba(255, 255, 255, 0.08);
      }

      .transfer-card {
        background: rgba(46, 48, 53, 0.75);
        border-radius: 14px;
        padding: 0.9rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.28);
      }

      .transfer-card__header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.35rem;
      }

      .transfer-card__icon {
        width: 46px;
        height: 46px;
        border-radius: 12px;
        display: grid;
        place-items: center;
        font-size: 1.4rem;
        color: #fff;
      }

      .transfer-card__icon--incoming {
        background: linear-gradient(135deg, rgba(46, 204, 113, 0.22), rgba(39, 174, 96, 0.35));
        border: 1px solid rgba(46, 204, 113, 0.45);
      }

      .transfer-card__icon--outgoing {
        background: linear-gradient(135deg, rgba(114, 137, 218, 0.22), rgba(114, 137, 218, 0.4));
        border: 1px solid rgba(114, 137, 218, 0.5);
      }

      .transfer-card__meta {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
      }

      .transfer-card__filename {
        font-weight: 700;
        color: #fff;
      }

      .transfer-card__filesize {
        color: rgba(255, 255, 255, 0.65);
        font-size: 0.9rem;
      }

      .transfer-card__status {
        color: rgba(255, 255, 255, 0.8);
        margin: 0.3rem 0;
      }

      .transfer-progress {
        width: 100%;
        height: 12px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 999px;
        overflow: hidden;
        position: relative;
        margin: 0.25rem 0 0.5rem 0;
      }

      .transfer-progress__fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #7289da, #61dafb);
        border-radius: 999px;
        box-shadow: 0 0 12px rgba(114, 137, 218, 0.6);
        transition: width 0.15s ease;
      }

      .transfer-stats {
        display: flex;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.75);
        font-size: 0.9rem;
        gap: 0.5rem;
      }

      .transfer-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.65rem;
      }

      .transfer-btn {
        flex: 1;
        border: none;
        padding: 0.55rem 0.75rem;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.2s ease;
      }

      .transfer-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      }

      .transfer-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .transfer-btn--accept {
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        color: #fff;
      }

      .transfer-btn--reject,
      .transfer-btn--cancel {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: #fff;
      }

      .transfer-btn--ghost {
        background: rgba(255, 255, 255, 0.08);
        color: #e4e6eb;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .radar-container {
        margin: 0.75rem 0 0 0;
        height: 560px;
      }

      .radar-viewport {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35);
        background: radial-gradient(circle at 50% 40%, rgba(66, 69, 73, 0.35), rgba(32, 34, 37, 0.95));
        background-image:
          radial-gradient(circle at 50% 40%, rgba(114, 137, 218, 0.08), rgba(32, 34, 37, 0)),
          repeating-linear-gradient(
            to right,
            rgba(255, 255, 255, 0.04) 0,
            rgba(255, 255, 255, 0.04) 1px,
            transparent 1px,
            transparent 80px
          ),
          repeating-linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.04) 0,
            rgba(255, 255, 255, 0.04) 1px,
            transparent 1px,
            transparent 80px
          );
        cursor: grab;
      }

      .radar-viewport.is-grabbing {
        cursor: grabbing;
      }

      .radar-world {
        position: absolute;
        width: 1600px;
        height: 1600px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transform-origin: center center;
        will-change: transform;
      }

      .radar-peers {
        position: absolute;
        inset: 0;
      }

      .radar-center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 140px;
        height: 140px;
        display: grid;
        place-items: center;
      }

      .ripple {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 160px;
        height: 160px;
        border: 1px solid rgba(114, 137, 218, 0.5);
        border-radius: 50%;
        animation: ripple 3s infinite;
        box-shadow: 0 0 30px rgba(114, 137, 218, 0.2);
      }

      .ripple.ripple-delay {
        animation-delay: 1.5s;
      }

      @keyframes ripple {
        0% {
          transform: translate(-50%, -50%) scale(0.6);
          opacity: 0.9;
        }
        100% {
          transform: translate(-50%, -50%) scale(1.4);
          opacity: 0;
        }
      }

      .self-avatar,
      .peer-avatar {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.4rem;
      }

      .self-avatar {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        background: linear-gradient(145deg, rgba(114, 137, 218, 0.8), rgba(97, 218, 251, 0.6));
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        display: grid;
        place-items: center;
        border: 4px solid rgba(255, 255, 255, 0.15);
      }

      .self-avatar img,
      .peer-avatar img {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(255, 255, 255, 0.25);
        background: #202225;
      }

      .self-label {
        margin-top: 0.25rem;
        font-weight: 700;
        color: #fff;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
      }

      .peer-avatar {
        width: 78px;
        height: 78px;
        border-radius: 50%;
        background: rgba(47, 49, 54, 0.9);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.05);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .peer-avatar:hover {
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 12px 30px rgba(114, 137, 218, 0.35), 0 0 0 1px rgba(114, 137, 218, 0.4);
        background: rgba(114, 137, 218, 0.15);
      }

      .peer-name {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.85);
        text-align: center;
        max-width: 120px;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }

      .radar-empty {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.95rem;
      }

      .header-user {
        display: inline-flex;
        align-items: center;
        gap: 0.75rem;
        background: linear-gradient(135deg, rgba(114, 137, 218, 0.15), rgba(32, 34, 37, 0.6));
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 999px;
        padding: 0.35rem 0.9rem 0.35rem 0.4rem;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
        transition: border-color 0.2s ease, transform 0.2s ease;
      }

      .header-user:hover {
        border-color: rgba(114, 137, 218, 0.6);
        transform: translateY(-1px);
      }

      .header-user__avatar {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(255, 255, 255, 0.08);
        background: #202225;
      }

      .header-user__name {
        font-weight: 700;
        letter-spacing: 0.3px;
      }

      #profile {
        max-width: 1100px;
        margin: 0 auto;
      }

      .profile-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.2rem;
        margin-top: 1.5rem;
      }

      .profile-card {
        background: linear-gradient(145deg, rgba(32, 34, 37, 0.9), rgba(54, 57, 63, 0.85));
        border-radius: 14px;
        padding: 1.25rem 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
        text-align: left;
      }

      .profile-card h3 {
        margin-bottom: 0.75rem;
        color: #fff;
        letter-spacing: 0.4px;
      }

      .profile-card p {
        color: #aeb2b8;
        margin-bottom: 0.5rem;
      }

      .profile-avatar-wrapper {
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .profile-avatar-preview {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid rgba(114, 137, 218, 0.45);
        box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
        background: #202225;
      }

      .profile-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        flex-wrap: wrap;
      }

      .profile-input {
        width: 100%;
        background: #202225;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 0.85rem 0.95rem;
        margin: 0.35rem 0 0.85rem;
        outline: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .profile-input:focus {
        border-color: rgba(114, 137, 218, 0.75);
        box-shadow: 0 0 0 3px rgba(114, 137, 218, 0.12);
      }

      .ghost-button,
      .primary-button {
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(114, 137, 218, 0.12);
        color: #e3e5e8;
        padding: 0.65rem 1.1rem;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
      }

      .ghost-button:hover,
      .primary-button:hover {
        background: rgba(114, 137, 218, 0.25);
        border-color: rgba(114, 137, 218, 0.6);
        transform: translateY(-1px);
      }

      .primary-button {
        background: linear-gradient(135deg, #7289da, #5b6eae);
        color: #fff;
        border: none;
      }

      .profile-status {
        font-size: 0.95rem;
        color: #9ea3ab;
        margin-top: 0.5rem;
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 1;
        transition: opacity 0.2s ease;
        pointer-events: auto;
      }

      .modal-overlay--visible {
        display: flex;
        opacity: 1;
        pointer-events: auto;
      }

      .file-modal {
        background: #2f3136;
        padding: 1.5rem;
        border-radius: 12px;
        width: min(420px, 90%);
        box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.08);
        color: var(--text-primary);
        position: relative;
      }

      .file-modal h3 {
        margin-bottom: 0.75rem;
        color: #fff;
        font-size: 1.35rem;
      }

      .file-modal__close {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: #a9abb0;
        font-size: 1.25rem;
        cursor: pointer;
        line-height: 1;
      }

      .file-modal__close:hover {
        color: #fff;
      }

      .file-modal__details {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        padding: 0.75rem 1rem;
        border-radius: 10px;
        margin-bottom: 1rem;
      }

      .file-modal__details p {
        margin-bottom: 0.35rem;
      }

      .file-modal__details p:last-child {
        margin-bottom: 0;
      }

      .file-modal__actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }

      .file-modal__actions button {
        border: none;
        padding: 0.65rem 1.1rem;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
      }

      .file-modal__reject {
        background: #3a3d42;
        color: #fff;
      }

      .file-modal__accept {
        background: var(--accent);
        color: #fff;
      }
      :root {
        --bg-primary: #36393f; /* Discord dark gray */
        --bg-secondary: #2f3136; /* Slightly darker for header */
        --text-primary: #dcddde; /* Light gray text */
        --accent: #7289da; /* Discord blurple */
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: "Helvetica Neue", Arial, sans-serif;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        text-align: center;
        padding: 0; /* Remove outer spacing so header and footer reach page edges */
      }

      header {
        background: var(--bg-secondary);
        padding-bottom: 1rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        width: 100%;
      }

      .banner {
        width: 100%;
        max-height: 300px;
        object-fit: cover;
        display: block;
      }

      h1 {
        margin-top: 1rem;
        font-size: 56px;
        color: var(--accent);
      }

      nav {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
        gap: 1rem;
        flex-wrap: wrap;
        border-top: 1px solid #202225;
        border-bottom: 1px solid #202225;
        padding: 0.5rem 0;
      }

      nav a {
        color: var(--text-primary);
        text-decoration: none;
        padding: 0.5rem 1rem;
        font-size: 1.1rem;
        border-radius: 4px;
        transition: background 0.2s;
      }

      nav a:hover,
      nav a.active {
        background: var(--accent);
        color: #fff;
      }

      main {
        flex: 1;
        padding: 2rem;
      }

      section {
        display: none;
        max-width: 800px;
        margin: 0 auto;
        text-align: left;
        line-height: 1.6;
      }

      section.active {
        display: block;
      }

      .hero {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1.5rem;
        text-align: center;
        padding: 3rem 2rem;
        background: linear-gradient(145deg, rgba(47, 49, 54, 0.85), rgba(54, 57, 63, 0.8));
        border-radius: 16px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      }

      .hero__title {
        font-size: clamp(2.5rem, 5vw, 3.5rem);
        font-weight: 700;
        color: #fff;
        letter-spacing: 0.03em;
      }

      .hero__description {
        font-size: 1.1rem;
        color: #b9bbbe;
        max-width: 640px;
      }

      .hero__actions {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        width: 100%;
      }

      .hero__button {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 999px;
        padding: 0.85rem 2.5rem;
        font-size: 1.05rem;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 10px 25px rgba(114, 137, 218, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .hero__button:hover,
      .hero__button:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 14px 32px rgba(114, 137, 218, 0.45);
        outline: none;
      }

      .summary-card {
        display: none;
        background: rgba(32, 34, 37, 0.95);
        border-radius: 14px;
        padding: 2rem;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.05);
        max-width: 900px;
        width: min(100%, 900px);
        text-align: left;
        line-height: 1.7;
        gap: 1.5rem;
      }

      .summary-card.summary-card--visible {
        display: flex;
        flex-direction: column;
        animation: fadeInUp 0.25s ease forwards;
      }

      .summary-card__body {
        max-height: 340px;
        overflow-y: auto;
        padding-right: 0.5rem;
        color: #e3e5e8;
      }

      .summary-card__close {
        align-self: center;
        background: #3a3d42;
        color: #fff;
        border: none;
        border-radius: 999px;
        padding: 0.75rem 2rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .summary-card__close:hover,
      .summary-card__close:focus-visible {
        background: #484b51;
        transform: translateY(-1px);
        outline: none;
      }

      .is-hidden {
        display: none !important;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      #klipek {
        max-width: 1800px;
        width: min(96vw, 1800px);
        margin: 0 auto;
        position: relative;
      }

      .clips-content {
        position: relative;
        z-index: 1;
        transition: filter 0.2s ease, opacity 0.2s ease;
      }

      #klipek.permission-blocked .clips-content {
        filter: grayscale(1) blur(4px);
        opacity: 0.35;
        pointer-events: none;
        user-select: none;
      }

      .permission-overlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 2rem;
        background: radial-gradient(circle, rgba(17, 20, 27, 0.8) 0%, rgba(12, 14, 18, 0.95) 100%);
        backdrop-filter: blur(6px);
        z-index: 2;
      }

      #klipek.permission-blocked .permission-overlay {
        display: flex;
      }

      .permission-overlay__content {
        max-width: 560px;
        background: rgba(22, 25, 31, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 2rem;
        color: #e6e9f0;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      .permission-overlay__content h3 {
        margin-bottom: 0.5rem;
        font-size: 1.4rem;
      }

      .permission-overlay__content p {
        color: #c6cad4;
        margin: 0;
      }

      .clips-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .clip-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin: 1rem 0;
        background: #1f2227;
        padding: 1rem;
        border-radius: 10px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
        align-items: flex-start;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        flex: 1 1 230px;
      }

      .filter-group label {
        font-size: 0.9rem;
        color: #c9d1d9;
      }

      .filter-group input,
      .filter-group select {
        background: #2c2f33;
        border: 1px solid #3c4047;
        color: #fff;
        padding: 0.6rem 0.75rem;
        border-radius: 8px;
      }

      .filter-group--actions {
        flex: 0 0 auto;
        align-self: center;
        display: flex;
        align-items: center;
        margin-left: auto;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      #video-grid-container {
        margin: 1.25rem auto 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 1.25rem;
        width: 100%;
      }

      .video-card {
        background: #1f2227;
        padding: 1rem;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
        border: 1px solid #2f333a;
      }

      .video-card video {
        width: 100%;
        border-radius: 10px;
        background: #000;
        aspect-ratio: 16 / 9;
        object-fit: cover;
      }

      .video-card__title {
        font-size: clamp(0.95rem, 0.65vw + 0.8rem, 1.05rem);
        font-weight: 700;
        margin: 0;
        color: #fff;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        line-height: 1.3;
      }

      .video-card__meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.95rem;
        color: #c9d1d9;
      }

      .tag-list {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.25rem 0.35rem;
      }

      .tag-chip {
        --tag-color: #5865f2;
        background: var(--tag-color);
        color: #fff;
        padding: 0.18rem 0.5rem;
        border-radius: 10px;
        font-size: 0.75rem;
        line-height: 1.2;
        font-weight: 600;
        border: 1px solid var(--tag-color);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.12);
      }

      @media (max-width: 1200px) {
        #video-grid-container {
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }
      }

      @media (max-width: 768px) {
        #video-grid-container {
          grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
      }

      .video-card--error {
        border: 1px solid #ff6b6b;
      }

      .video-card__error {
        color: #ffb1b1;
        font-size: 0.9rem;
        font-weight: 400;
      }

      .video-card__actions {
        display: flex;
        justify-content: flex-end;
      }

      .delete-btn {
        background: #d63c3c;
        border: none;
        color: #fff;
        padding: 0.45rem 0.75rem;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 700;
      }

      .delete-btn:hover {
        background: #b22f2f;
      }

      .pagination {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.4rem;
        margin: 1.25rem 0 0.5rem;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding: 0.25rem;
      }

      .pagination button {
        background: #2f3136;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.05);
        width: 42px;
        height: 42px;
        border-radius: 8px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
      }

      .pagination button.active {
        background: #5865f2;
        border-color: #5865f2;
        font-weight: 700;
        color: #fff;
      }

      .pagination button:hover {
        background: #3a3c43;
        border-color: rgba(255, 255, 255, 0.08);
      }

      .pagination span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        background: #2f3136;
        color: #e5e7eb;
        border-radius: 8px;
      }

      .modal-grid {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 1rem;
      }

      .drop-zone {
        background: #1f2227;
        border: 2px dashed #3c4047;
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        color: #c9d1d9;
        cursor: pointer;
      }

      .drop-zone.drag-over {
        border-color: #2d6cdf;
        background: rgba(45, 108, 223, 0.1);
      }

      #selectedFilesList {
        list-style: none;
        padding: 0;
        margin: 0.75rem 0 0;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .tag-checklist {
        background: #1f2227;
        border: 1px solid #3c4047;
        border-radius: 10px;
        padding: 0.75rem;
        max-height: 240px;
        overflow-y: auto;
      }

      .tag-checklist label {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        padding: 0.35rem 0;
      }

      .create-tag-row {
        display: flex;
        gap: 0.75rem;
        margin-top: 0.5rem;
        align-items: flex-start;
        flex-wrap: wrap;
      }

      .tag-field-group {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        width: 220px;
      }

      .create-tag-row input[type="text"] {
        background: #2c2f33;
        border: 1px solid #3c4047;
        color: #fff;
        padding: 0.5rem 0.65rem;
        border-radius: 8px;
        width: 100%;
      }

      .create-tag-row button {
        background: #2d6cdf;
        color: #fff;
        border: none;
        padding: 0.5rem 0.75rem;
        border-radius: 8px;
        cursor: pointer;
        width: 100%;
      }

      .tag-action-group {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        min-width: 140px;
      }

      .danger-btn {
        background: #d84848;
        border: 1px solid rgba(0, 0, 0, 0.15);
      }

      .danger-btn:hover {
        background: #c13c3c;
      }

      .tag-color-button {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: #fff;
        font-weight: 600;
        padding: 0.5rem 0.9rem;
        border-radius: 10px;
        cursor: pointer;
        width: 100%;
        justify-content: center;
      }

      .tag-color-button:hover {
        border-color: rgba(255, 255, 255, 0.22);
        background: rgba(255, 255, 255, 0.1);
      }

      .tag-color-button .tag-color-swatch {
        width: 18px;
        height: 18px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.35);
        background: var(--tag-color, #5865f2);
      }

      .tag-color-input {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
        pointer-events: none;
      }

      /* A HOI4 sorsoló szekciónál ne legyen szélességkorlát, hogy a négy doboz egymás mellett
         maradjon */
      #sorsolas {
        max-width: none;
      }

      /* Szavazás stílusok */
      #szavazas.active {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .poll-card {
        background: #2c2f33;
        padding: 1rem;
        border: 1px solid #202225;
        border-radius: 6px;
      }

      .poll-card h3 {
        margin-top: 0;
        margin-bottom: 0.75rem;
      }

      .poll-hint {
        color: #b9bbbe;
        font-size: 0.9rem;
        margin-bottom: 0.75rem;
      }

      .poll-text-input {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.75rem;
        color: var(--text-primary);
        background: #1e2124;
        border: 1px solid #202225;
        border-radius: 4px;
      }

      .poll-options-inputs {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .poll-option-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .poll-option-input {
        flex: 1;
        padding: 0.75rem;
        color: var(--text-primary);
        background: #1e2124;
        border: 1px solid #202225;
        border-radius: 4px;
        font-size: 1rem;
      }

      .poll-option-remove {
        width: auto; /* Felülírja a globális 100%-os szélességet */
        background: #202225;
        border: none;
        color: #fff;
        border-radius: 4px;
        padding: 0.25rem 0.5rem; /* Visszaállítva az eredetire a kisebb méretért */
        cursor: pointer;
        font-size: 1rem;
        line-height: 1;
      }

      .poll-option-remove:hover:not(:disabled) {
        background: #f04747;
      }

      .poll-option-remove:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .poll-creator-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.75rem;
        flex-wrap: wrap;
      }

      .poll-button {
        background: var(--accent);
        border: none;
        padding: 0.5rem 1rem;
        color: #fff;
        cursor: pointer;
        border-radius: 4px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.25rem;
        font-weight: 600;
      }

      .poll-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .poll-secondary-btn {
        background: #3a3d42;
      }

      .poll-secondary-btn:hover:not(:disabled) {
        background: #484b51;
      }

      .poll-primary-btn:hover:not(:disabled),
      .poll-vote-btn:hover:not(:disabled) {
        filter: brightness(1.05);
      }

      .poll-close-btn {
        background: #f04747;
      }

      .poll-close-btn:hover:not(:disabled) {
        background: #ff5c5c;
      }

      .poll-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .poll-card-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }

      .poll-status {
        background: #1e2124;
        border-radius: 999px;
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: #b9bbbe;
      }

      .poll-status--active {
        color: #57f287;
      }

      .poll-status--closed {
        color: #f04747;
      }

      .poll-meta {
        font-size: 0.85rem;
        color: #b9bbbe;
      }

      .poll-options-results {
        margin-top: 0.75rem;
      }

      .poll-option-result {
        padding: 0.75rem 0;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
      }

      .poll-option-result:first-of-type {
        border-top: none;
      }

      .poll-option-result--selected {
        border-left: 3px solid var(--accent);
        padding-left: 0.75rem;
        background: rgba(114, 137, 218, 0.08);
      }

      .poll-option-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .poll-option-label {
        flex: 1 1 auto;
        font-weight: 600;
      }

      .poll-option-count {
        font-size: 0.85rem;
        color: #b9bbbe;
      }

      .poll-badge {
        background: rgba(114, 137, 218, 0.2);
        color: var(--accent);
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .poll-result-bar {
        width: 100%;
        height: 0.75rem;
        background: #1e2124;
        border: 1px solid #202225;
        border-radius: 999px;
        overflow: hidden;
        margin-top: 0.5rem;
      }

      .poll-result-bar-fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, var(--accent), #5865f2);
        transition: width 0.3s ease;
      }

      .poll-option-result--selected .poll-result-bar-fill {
        background: linear-gradient(90deg, #57f287, var(--accent));
      }

      .poll-voters {
        margin-top: 0.4rem;
        font-size: 0.8rem;
        color: #b9bbbe;
      }

      .poll-total-votes {
        margin-top: 0.75rem;
        font-size: 0.85rem;
        color: #b9bbbe;
      }

      .poll-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .poll-empty {
        background: #2c2f33;
        padding: 1rem;
        border: 1px solid #202225;
        border-radius: 6px;
        text-align: center;
        color: #b9bbbe;
      }

        footer {
          width: 100%;
          padding: 1rem;
          font-size: 0.875rem;
          background: rgb(47, 49, 54);
        }
      /* Programok szekció stílusai */
      #programok {
        position: relative;
      }

      .programs-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .programs-subtitle {
        color: rgba(255, 255, 255, 0.65);
        margin-top: 0.35rem;
      }

      .program-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem;
        width: 100%;
      }

      .program-card {
        position: relative;
        background: linear-gradient(145deg, rgba(34, 36, 40, 0.9), rgba(21, 22, 25, 0.9));
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 14px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: 0 16px 35px rgba(0, 0, 0, 0.35);
        height: 100%;
      }

      .program-card__thumbnail {
        width: 100%;
        aspect-ratio: 1 / 1;
        object-fit: cover;
        background: #d8dadd;
        border-radius: 50%;
        padding: 0.75rem;
        box-sizing: border-box;
        display: block;
      }

      .program-card__body {
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        flex: 1;
      }

      .program-card__title {
        margin: 0;
      }

      .program-card__description {
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
        min-height: 44px;
      }

      .program-card__meta {
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.9rem;
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .program-card__actions {
        display: flex;
        gap: 0.5rem;
        margin-top: auto;
      }

      .program-card__download {
        flex: 1;
      }

      .program-card__delete {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 34px;
        height: 34px;
        border-radius: 10px;
        border: none;
        display: none;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #ff5555, #c0392b);
        color: #fff;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      }

      .program-card__edit {
        position: absolute;
        top: 10px;
        right: 52px;
        width: 34px;
        height: 34px;
        border-radius: 10px;
        border: none;
        display: none;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #4a90e2, #2a73c5);
        color: #fff;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      }

      .program-card.program-card--admin .program-card__delete {
        display: inline-flex;
      }

      .program-card.program-card--admin .program-card__edit {
        display: inline-flex;
      }

      .programs-empty {
        padding: 1rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.03);
        border: 1px dashed rgba(255, 255, 255, 0.1);
        border-radius: 12px;
      }

      .program-upload-form .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .program-upload-form input,
      .program-upload-form textarea {
        background: #1e2124;
        border: 1px solid #2c2f33;
        color: #fff;
        border-radius: 10px;
        padding: 0.75rem;
      }

      .program-upload-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }

      .program-upload-tile {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 0.9rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .tile-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .tile-hint {
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.9rem;
      }

      .program-cropper-wrapper {
        background: #d8dadd;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        min-height: 220px;
        display: grid;
        place-items: center;
        overflow: hidden;
      }

      .program-cropper-wrapper img {
        max-width: 100%;
        display: block;
      }

      .program-file-name {
        color: rgba(255, 255, 255, 0.7);
        margin: 0;
      }

      .upload-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .upload-modal-close {
        background: transparent;
        border: none;
        color: #fff;
        font-size: 1.2rem;
        cursor: pointer;
      }

      .user-table {
        width: 100%;
        max-width: 600px;
        margin-top: 1rem;
        border-collapse: collapse;
      }

      .user-table th,
      .user-table td {
        padding: 0.75rem;
        text-align: left;
        border-bottom: 1px solid #4f545c;
      }

      .user-table input[type="number"] {
        width: 100%;
        max-width: 120px;
        padding: 0.4rem;
        border-radius: 4px;
        border: 1px solid #202225;
        background: #1e2124;
        color: var(--text-primary);
      }

      .user-table th {
        background-color: var(--bg-secondary);
      }

      .user-table tbody tr:hover {
        background-color: #3c4046;
      }

      .permission-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .admin-description {
        margin-top: 0.5rem;
        max-width: 600px;
      }

      .admin-clips-actions {
        margin-top: 1rem;
      }

      #loadClipsBtn {
        padding: 0.65rem 1.25rem;
      }

      #savePermissionsBtn {
        margin-top: 1.5rem;
        padding: 0.75rem 1.5rem;
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
      }

      #savePermissionsBtn:hover:not(:disabled) {
        background: #5b6dad;
      }

      #savePermissionsBtn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Auth buttons */
      .auth-buttons {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .auth-buttons__group {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .auth-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 0.6rem 1.4rem;
        margin-left: 0.25rem;
        border-radius: 4px;
        cursor: pointer;
        text-decoration: none;
        min-width: 150px;
        font-weight: 600;
      }

      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        padding: 1rem;
      }

      .upload-modal-content {
        background: var(--bg-secondary);
        padding: 1.25rem 1.5rem 1rem;
        border-radius: 12px;
        width: 100%;
        max-width: 860px;
        position: relative;
        box-shadow: 0 14px 45px rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.06);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .upload-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .upload-modal-title {
        margin: 0;
        font-size: 1.25rem;
        letter-spacing: 0.5px;
      }

      .close-btn {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        width: 42px;
        height: 42px;
        display: grid;
        place-items: center;
        font-size: 1.3rem;
        cursor: pointer;
        color: #fff;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      }

      .close-btn:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.16);
      }

      .upload-modal-toolbar {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 0.85rem 1rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
      }

      .upload-modal-toolbar label {
        color: rgba(255, 255, 255, 0.75);
        font-weight: 600;
        margin-right: 0.5rem;
      }

      .toolbar-tags {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex: 1;
        min-width: 220px;
      }

      #globalTagSelect,
      .queue-tag-select {
        background: #2f3238;
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 10px;
        color: #fff;
        padding: 0.45rem 0.75rem;
        min-width: 260px;
        min-height: 54px;
        max-height: 264px;
        overflow-y: auto;
      }

      #globalTagSelect option,
      .queue-tag-select option {
        background: #1f2126;
        padding: 0.35rem 0.6rem;
      }

      #globalTagSelect::-webkit-scrollbar,
      .queue-tag-select::-webkit-scrollbar {
        width: 8px;
      }

      #globalTagSelect::-webkit-scrollbar-thumb,
      .queue-tag-select::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.22);
        border-radius: 8px;
        border: 2px solid rgba(0, 0, 0, 0.15);
      }

      #globalTagSelect::-webkit-scrollbar-track,
      .queue-tag-select::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.06);
        border-radius: 8px;
      }

      #globalTagSelect option:checked,
      .queue-tag-select option:checked {
        background: linear-gradient(90deg, rgba(114, 137, 218, 0.3), rgba(114, 137, 218, 0.1));
        color: #fff;
        font-weight: 700;
        border-left: 4px solid var(--accent);
      }

      .tag-pill-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 0.35rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 0.35rem;
        max-height: 180px;
        overflow-y: auto;
        align-content: start;
      }

      .tag-pill {
        --tag-color: #5865f2;
        display: inline-flex;
        align-items: center;
        justify-content: flex-start;
        gap: 0.35rem;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.04));
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        padding: 0.35rem 0.6rem;
        border-radius: 12px;
        cursor: pointer;
        transition: transform 0.1s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        font-size: 0.9rem;
        line-height: 1.25;
        min-width: 0;
      }

      .tag-pill__dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--tag-color);
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.2);
      }

      .tag-pill--selected {
        border-color: var(--tag-color);
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.05);
        background: linear-gradient(135deg, rgba(88, 101, 242, 0.18), rgba(88, 101, 242, 0.08));
      }

      .tag-pill:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.25);
      }

      #drop-zone {
        border: 2px dashed var(--accent);
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        background: rgba(114, 137, 218, 0.1);
        transition: background 0.2s, border-color 0.2s;
        margin-bottom: 1rem;
      }

      #drop-zone.drag-over {
        background: rgba(114, 137, 218, 0.2);
        border-color: #99a9e6;
      }

      #drop-zone p {
        margin-bottom: 0.5rem;
      }

      .upload-queue-container {
        background: rgba(255, 255, 255, 0.02);
        border: 1px dashed rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 0.75rem;
        min-height: 140px;
        max-height: 400px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .upload-queue-container::-webkit-scrollbar {
        width: 8px;
      }

      .upload-queue-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.06);
        border-radius: 999px;
      }

      .upload-queue-container::-webkit-scrollbar-thumb {
        background: #505461;
        border-radius: 999px;
      }

      .upload-queue-item {
        display: flex;
        align-items: center;
        gap: 0.85rem;
        background: rgba(54, 57, 63, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 0.75rem 0.9rem;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
      }

      .queue-thumbnail {
        width: 80px;
        height: 45px;
        border-radius: 8px;
        background: #202226;
        border: 1px solid rgba(255, 255, 255, 0.08);
        overflow: hidden;
        display: grid;
        place-items: center;
        flex-shrink: 0;
      }

      .queue-thumbnail img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .queue-details {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .queue-details input[type="text"] {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #2c2f36;
        color: #fff;
      }

      .queue-actions {
        display: flex;
        align-items: center;
        gap: 0.35rem;
      }

      .queue-remove {
        background: rgba(231, 76, 60, 0.15);
        border: 1px solid rgba(231, 76, 60, 0.4);
        color: #ffada3;
        border-radius: 8px;
        width: 42px;
        height: 42px;
        display: grid;
        place-items: center;
        font-size: 1.15rem;
        cursor: pointer;
        transition: transform 0.1s ease, background 0.2s ease;
      }

      .queue-remove:hover {
        background: rgba(231, 76, 60, 0.25);
        transform: scale(1.03);
      }

      .upload-modal-footer {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-top: 0.25rem;
        flex-wrap: wrap;
      }

      .upload-modal-footer > div:first-child {
        flex: 1;
        min-width: 240px;
      }

      .upload-action-buttons {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .upload-summary {
        color: rgba(255, 255, 255, 0.72);
        font-weight: 600;
        flex: 1;
        min-width: 200px;
      }

      .primary-btn {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 10px;
        padding: 0.75rem 1.35rem;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.5px;
        transition: background 0.2s ease, transform 0.1s ease;
      }

      .primary-btn.large {
        padding: 0.95rem 1.75rem;
        font-size: 1.05rem;
      }

      .primary-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .primary-btn:hover:not(:disabled) {
        background: #5b6dad;
      }

      .secondary-btn {
        background: rgba(255, 255, 255, 0.06);
        color: #e4e6eb;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 10px;
        padding: 0.75rem 1.2rem;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.3px;
        transition: background 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
      }

      .secondary-btn.large {
        padding: 0.9rem 1.55rem;
      }

      .secondary-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .secondary-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.24);
      }

      .upload-toast {
        background: rgba(231, 76, 60, 0.14);
        border: 1px solid rgba(231, 76, 60, 0.35);
        color: #ffcbc2;
        padding: 0.5rem 0.75rem;
        border-radius: 10px;
        font-weight: 600;
        opacity: 0;
        transform: translateY(-6px);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .upload-toast.upload-toast--visible {
        opacity: 1;
        transform: translateY(0);
      }

      .clip-toast {
        position: fixed;
        right: 20px;
        bottom: 20px;
        background: rgba(56, 189, 248, 0.16);
        border-color: rgba(56, 189, 248, 0.4);
        color: #e6f7ff;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35);
        z-index: 1100;
      }

      .upload-status {
        margin: 0;
        color: rgba(255, 255, 255, 0.7);
      }

      .upload-progress {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 0.65rem 0.75rem;
        margin-top: 0.35rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .upload-progress__bar {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        overflow: hidden;
        height: 10px;
      }

      .upload-progress__fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #6f8bff, #9c6dff);
        transition: width 0.15s ease;
      }

      .upload-progress__meta {
        display: flex;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.78);
        font-weight: 600;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .upload-progress__details {
        color: rgba(255, 255, 255, 0.72);
        font-size: 0.95rem;
      }

      .upload-modal-content.shake {
        animation: uploadShake 0.35s ease;
      }

      @keyframes uploadShake {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-4px);
        }
        50% {
          transform: translateX(4px);
        }
        75% {
          transform: translateX(-3px);
        }
        100% {
          transform: translateX(0);
        }
      }

      #uploadBtn {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        width: 100%;
      }

      #uploadBtn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        margin-top: 0.75rem;
        min-height: 1.25rem;
      }

      /* Login modal */
      #loginModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1200;
      }

      #loginModal .modal-content {
        background: var(--bg-secondary);
        padding: 1rem;
        border-radius: 4px;
        width: 300px;
      }

      #loginModal input {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        border: 1px solid #202225;
        border-radius: 4px;
        background: #1e2124;
        color: var(--text-primary);
      }

      #loginModal button {
        width: 100%;
      }

      .feedback-modal {
        position: fixed;
        inset: 0;
        display: none;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1300;
        padding: 1rem;
      }

      .feedback-modal__content {
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 1.5rem;
        border-radius: 8px;
        width: min(90%, 360px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
        position: relative;
        text-align: center;
      }

      .feedback-modal__title {
        font-size: 1.25rem;
        margin-bottom: 0.75rem;
      }

      .feedback-modal__message {
        margin-bottom: 1.25rem;
      }

      .feedback-modal__close {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        background: transparent;
        border: none;
        color: inherit;
        font-size: 1.5rem;
        line-height: 1;
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border-radius: 999px;
        transition: background 0.2s, color 0.2s;
      }

      .feedback-modal__close:hover,
      .feedback-modal__close:focus-visible {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        outline: none;
      }

      .feedback-modal__actions button {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 0.5rem 1.5rem;
        border-radius: 4px;
        cursor: pointer;
      }

      .video-modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1400;
        padding: 2rem;
      }

      .video-modal.open {
        display: flex;
      }

      .video-modal__inner {
        position: relative;
        display: flex;
        align-items: center;
        gap: 1.5rem;
        width: 100%;
        max-width: 1400px;
      }

      .video-modal__content {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
      }

      .video-modal__video {
        width: 100%;
        max-width: 90%;
        max-height: 80vh;
        background: #000;
        border-radius: 8px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
      }

      .video-modal__title {
        color: #fff;
        font-size: 1.1rem;
        text-align: center;
        margin: 0;
      }

      .video-modal__nav {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: none;
        width: 56px;
        height: 56px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        pointer-events: auto;
        transition: background 0.2s ease;
      }

      .video-modal__nav:hover,
      .video-modal__nav:focus-visible {
        background: rgba(255, 255, 255, 0.2);
        outline: none;
      }

      .video-modal__nav--prev,
      .video-modal__nav--next {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
      }

      .video-modal__nav--prev {
        left: -0.5rem;
      }

      .video-modal__nav--next {
        right: -0.5rem;
      }

      .video-modal__close {
        position: absolute;
        top: -1rem;
        right: -1rem;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        border: none;
        width: 46px;
        height: 46px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        font-size: 1.6rem;
        line-height: 1;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .video-modal__close:hover,
      .video-modal__close:focus-visible {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
        outline: none;
      }

      .video-modal__nav-wrapper {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        pointer-events: none;
      }

      @media (max-width: 960px) {
        .video-modal {
          padding: 1rem;
        }

        .video-modal__inner {
          flex-direction: column;
          gap: 0.75rem;
        }

        .video-modal__content {
          width: 100%;
        }

        .video-modal__video {
          max-width: 100%;
          max-height: 60vh;
        }

        .video-modal__nav--prev,
        .video-modal__nav--next,
        .video-modal__close {
          position: static;
          transform: none;
        }

        .video-modal__nav-wrapper {
          position: static;
          display: flex;
          gap: 0.75rem;
          width: 100%;
          justify-content: center;
          pointer-events: auto;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>UMKGL HUB</h1>
      <nav>
        <a href="#home" data-section="home" class="active">Főoldal</a>
        <a
          href="#fajlkuldes"
          data-section="fajlkuldes"
          id="fileTransferNavBtn"
          data-requires-transfer="true"
          style="display: none;"
          >Fájlküldés</a
        >
        <a href="#klipek" data-section="klipek">Klippek</a>
        <a href="#sorsolas" data-section="sorsolas">Hoi4 Sorsolás</a>
        <a href="#szavazas" data-section="szavazas">Szavazás</a>
        <a
          href="#programok"
          data-section="programok"
          id="programNavBtn"
          >Programok</a
        >
        <a
          href="#admin"
          data-section="admin"
          id="adminNavBtn"
          data-requires-admin="true"
          style="display: none;"
          >Admin Mód</a
        >
      </nav>
      <div class="auth-buttons">
        <div id="authLoggedOut" class="auth-buttons__group">
          <button id="loginBtn" type="button" class="auth-button">Bejelentkezés</button>
          <button id="registerBtn" type="button" class="auth-button">Regisztráció</button>
        </div>
        <div id="authLoggedIn" class="auth-buttons__group" style="display: none">
          <a href="#profile" id="userProfileLink" data-section="profile" class="header-user">
            <img id="userAvatar" class="header-user__avatar" src="program_icons/default-avatar.png" alt="User Avatar">
            <span id="userGreeting" class="header-user__name"></span>
          </a>
          <button id="logoutBtn" type="button" class="auth-button">Kijelentkezés</button>
        </div>
      </div>
    </header>

    <div id="loginModal">
      <div class="modal-content">
        <span id="closeLogin" style="float: right; cursor: pointer">&times;</span>
        <h2>Bejelentkezés</h2>
        <form id="loginForm">
          <input type="text" id="loginUser" placeholder="Felhasználónév" required />
          <input type="password" id="loginPass" placeholder="Jelszó" required />
          <button type="submit">Belépés</button>
        </form>
      </div>
    </div>

    <div id="feedbackModal" class="feedback-modal" role="dialog" aria-modal="true" aria-labelledby="feedbackModalTitle" style="display: none">
      <div class="feedback-modal__content">
        <button id="feedbackModalClose" class="feedback-modal__close" type="button" aria-label="Bezárás">&times;</button>
        <h3 id="feedbackModalTitle" class="feedback-modal__title"></h3>
        <p id="feedbackModalMessage" class="feedback-modal__message"></p>
        <div class="feedback-modal__actions">
          <button id="feedbackModalOk" type="button">OK</button>
        </div>
      </div>
    </div>

    <div id="programUploadModal" class="upload-modal" style="display: none">
      <div class="upload-modal-content">
        <div class="upload-modal-header">
          <h3 id="programUploadTitle">Új Program Feltöltése</h3>
          <button id="closeProgramUploadModal" class="upload-modal-close" type="button">✕</button>
        </div>
        <form id="programUploadForm" class="program-upload-form">
          <div class="form-group">
            <label for="programNameInput">Program neve</label>
            <input type="text" id="programNameInput" name="name" placeholder="Adj meg egy nevet" required />
          </div>
          <div class="form-group">
            <label for="programDescriptionInput">Rövid leírás</label>
            <textarea
              id="programDescriptionInput"
              name="description"
              rows="3"
              placeholder="Pár szóban foglald össze, mit tud a program"
              required
            ></textarea>
          </div>
          <div class="program-upload-grid">
            <div class="program-upload-tile">
              <div class="tile-header">
                <label for="programImageInput">Borítókép</label>
                <span class="tile-hint">PNG vagy JPG, kör alakú kivágással</span>
              </div>
              <label class="ghost-button" for="programImageInput">Kép kiválasztása</label>
              <input type="file" id="programImageInput" accept="image/png,image/jpeg,image/jpg" style="display: none" />
              <div class="program-cropper-wrapper">
                <img id="programImagePreview" alt="Program kép előnézet" />
              </div>
            </div>
            <div class="program-upload-tile">
              <div class="tile-header">
                <label for="programFileInput">Program fájl</label>
                <span class="tile-hint">.exe vagy .zip</span>
              </div>
              <input type="file" id="programFileInput" accept=".exe,.zip" required />
              <p id="programFileName" class="program-file-name">Nincs kiválasztva fájl.</p>
            </div>
          </div>
          <div class="upload-modal-actions">
            <button type="button" id="cancelProgramUploadBtn" class="ghost-button">Mégse</button>
            <button type="submit" id="submitProgramUploadBtn" class="primary-button">Mentés</button>
          </div>
        </form>
      </div>
    </div>

    <main>
      <!-- Főoldal -->
      <section id="home" class="active">
        <div class="hero">
          <h2 class="hero__title">
            Üdvözlünk az UMKGL Discord Szerver weboldalán!
          </h2>
         
          <div class="hero__actions">
            <button id="summaryToggleBtn" type="button" class="hero__button" aria-expanded="false">
              Rövid összefoglaló
            </button>
            <article id="summaryCard" class="summary-card" aria-live="polite" aria-hidden="true">
              <div class="summary-card__body">
                <p>
                  Az idő és a tér szövetének hajnalán, mintegy 13,8 milliárd évvel ezelőtt, a megfigyelhető univerzum egyetlen, felfoghatatlanul forró és sűrű pontban, egy gravitációs szingularitásban létezett. Ez a kezdeti állapot, amely megelőzte a fizika általunk ismert törvényeit, az Ősrobbanás néven ismert kataklizmikus eseménnyel egy exponenciális tágulásba kezdett. A tágulás első pikoszekundumaiban a négy alapvető kölcsönhatás – az erős nukleáris, a gyenge nukleáris, az elektromágneses és a gravitációs erő – szétvált egymástól, lehetővé téve a kvark-gluon plazma állapotában létező elemi részecskék számára, hogy kvarkokká és leptonokká differenciálódjanak. Ahogy az univerzum hűlt, ezen kvarkok protonokká és neutronokká álltak össze, megteremtve az atommagok építőköveit. Körülbelül 380 000 évvel a kezdetek után a hőmérséklet eléggé lecsökkent ahhoz, hogy a szabad elektronok befogódjanak az atommagok által, létrehozva az első semleges atomokat, elsősorban hidrogént és héliumot. Ez az esemény, az úgynevezett rekombináció, átlátszóvá tette az univerzumot a fény számára, és hátrahagyta a kozmikus mikrohullámú háttérsugárzást, amely ma is a Nagy Bumm visszhangjaként mérhető. A gravitáció, ez a láthatatlan, de rendíthetetlen erő, elkezdte munkáját: az anyag kezdetben parányi sűrűségingadozásait felerősítve hatalmas gázfelhőkké, protogalaxisokká vonta össze az ősi anyagot. Ezen galaxisok belsejében, csillagközi por- és gázködök sűrűsödésével meggyulladtak az első generációs csillagok. Ezen csillagok magjában a nukleáris fúzió poklában a hidrogén és hélium nehezebb elemekké, például szénné, oxigénné és vassá alakult. Életük végén ezek a csillagok szupernóva-robbanások formájában vetették ki magukból ezeket az elemeket, gazdagítva a csillagközi médiumot, és lehetővé téve a későbbi generációs, elem-gazdagabb csillagok és bolygórendszerek kialakulását.
                </p>
                <p>
                  Körülbelül 4,6 milliárd évvel ezelőtt, a Tejútrendszer Orion-karjának egy viszonylag csendes szegletében egy ilyen, nehéz elemekkel dúsított molekuláris felhő kezdett összeomlani saját gravitációja alatt. A felhő közepén kialakult egy protocsillag, a mi Napunk, míg a körülötte keringő anyag egy akkréciós korongba rendeződött. Ebben a protoplanetáris korongban a por és jégszemcsék ütközések és összetapadások révén egyre nagyobb égitestekké, planetezimálokká, majd protoplanétákká álltak össze. E folyamat eredményeként jött létre a Föld, egy kezdetben olvadt kőzetgolyó, amelyet folyamatosan bombáztak aszteroidák és üstökösök. A bolygó differenciálódása során a nehezebb elemek, mint a vas és a nikkel, a magba süllyedtek, míg a könnyebb szilikátok a köpenyt és a kérget alkották. A vulkáni tevékenységből származó gázok létrehozták a bolygó korai légkörét, és ahogy a felszín hűlt, a légkör vízgőztartalma lecsapódott, létrehozva az első óceánokat. Ebben a meleg, kémiai anyagokban gazdag "őslevesben", talán a mélytengeri hidrotermális kürtők környékén, az abiotikus kémiai evolúció során egyszerű szerves molekulákból (aminosavak, nukleotidok) létrejöttek az első önreprodukcióra képes polimerek, valószínűleg egy RNS-alapú világot teremtve. Ez vezetett az első, lipid membránnal körülvett sejtes életformák, a prokarióták megjelenéséhez. Évmilliárdokon keresztül ezek az egyszerű mikroorganizmusok voltak a Föld urai, a fotoszintézis feltalálásával pedig drámaian megváltoztatták a légkör összetételét, oxigénnel dúsítva azt. Az endoszimbiózis elmélete szerint egy ősi sejt bekebelezett más, specializált funkciójú baktériumokat, amelyekből a mai mitokondriumok és kloroplasztiszok lettek, ezzel létrehozva a jóval komplexebb eukarióta sejtet. Ez a lépés tette lehetővé a többsejtű élet robbanásszerű elterjedését a kambriumi időszakban, ami végül elvezetett az állatok, növények és gombák elképesztő változatosságához, és sok-sok evolúciós zsákutca és diadal után a Homo sapiens megjelenéséhez.
                </p>
                <p>
                  Az emberi faj evolúciójának kulcsmomentuma a kognitív forradalom volt, amely lehetővé tette az absztrakt gondolkodást, a tervezést és mindenekelőtt a komplex, szintaktikai szabályokra épülő nyelv használatát. Ez a képesség tette lehetővé a nagyméretű, rugalmas együttműködést, a mítoszok, törvények és közös hiedelmek megalkotását, amelyek messze meghaladták a kis vadászó-gyűjtögető csoportok méretét. A kommunikáció fejlődésének következő monumentális lépése az írás feltalálása volt, amely lehetővé tette az információk pontos, idő- és térbeli korlátok nélküli rögzítését és továbbítását. Az ékírástól a hieroglifákon át a föníciai ábécéig az írás forradalmasította a közigazgatást, a kereskedelmet és a tudás felhalmozását. Évszázadokon keresztül a tudás másolása azonban lassú, fáradságos kézi munka maradt, ami korlátozta annak terjedését. Johannes Gutenberg 15. századi találmánya, a mozgatható betűs nyomdagép, demokratizálta az információt, elindítva a reneszánszt, a reformációt és a tudományos forradalmat. Az ipari forradalom gőzgépei és gyárai után az elektromosság korának eljövetele hozta el a következő kommunikációs ugrást. A távíró, a telefon, majd a rádió és a televízió szinte nullára csökkentette a távolság jelentette kommunikációs akadályt. A 20. század közepén a tranzisztor feltalálása és az integrált áramkörök kifejlesztése megnyitotta az utat a digitális számítógépek előtt. A hidegháborús fegyverkezési verseny melléktermékeként az amerikai hadsereg megbízásából létrejött az ARPANET, egy decentralizált, csomagkapcsolt hálózat, amelynek célja a kommunikációs vonalak egy nukleáris támadás esetén való fenntartása volt. Ez a hálózat, a TCP/IP protokoll szabványosításával, a modern internet gerincévé vált. Tim Berners-Lee munkássága a CERN-ben, a World Wide Web, a HTTP protokoll és a HTML leíró nyelv megalkotása pedig végleg a tömegek számára is elérhetővé és használhatóvá tette a globális hálózatot.
                </p>
                <p>
                  Az internet elterjedésével párhuzamosan megjelentek az első digitális közösségek: BBS-ek, Usenet csoportok, majd az IRC csatornák. A 2000-es években a közösségi média platformok és a multiplayer online videójátékok (különösen az MMORPG-k, mint a World of Warcraft) robbanásszerű népszerűsége egy specifikus és sürgető problémát vetett fel. A játékosoknak szükségük volt egy megbízható, valós idejű, alacsony késleltetésű hangkommunikációs megoldásra, amely nem terheli agyon a számítógép erőforrásait játék közben. A korabeli megoldások, mint a Ventrilo vagy a TeamSpeak, nehézkesek voltak, gyakran saját szerver üzemeltetését igényelték, és a felhasználói felületük sem volt a legbarátságosabb. Ezt a piaci rést ismerte fel Jason Citron, az OpenFeint közösségi játékplatform alapítója, és Stanislav Vishnevskiy. Céljuk egy olyan szolgáltatás létrehozása volt, amely egyesíti a szöveges és hangalapú csevegés előnyeit egyetlen, könnyen használható, böngészőből is futtatható, és mindenki számára ingyenesen elérhető szerverinfrastruktúrát biztosító platformon. Így született meg 2015-ben a Discord. A platform, amely eredetileg a játékosokat célozta, intuitív felületének, kiváló teljesítményének és testreszabhatóságának köszönhetően hamarosan túlnőtt a gaming világán. Különböző érdeklődési körű csoportok, baráti társaságok, tanulóközösségek és szakmai szervezetek találtak otthonra a Discord szerverein, amely a 2020-as évek elejére a digitális közösségi élet egyik megkerülhetetlen központjává vált.
                </p>
                <p>
                  És ezen a ponton, a kozmikus evolúció 13,8 milliárd éves, elképesztően komplex és kauzális láncolatokból álló folyamatának végkifejleteként; a csillagporból formálódott bolygón kialakult, tudatra ébredt élet technológiai fejlődésének csúcspontján; a kommunikáció iránti ősi emberi vágy digitális térben való manifesztálódásának egy specifikus, előre elrendelt pillanatában, az összes szükséges fizikai, biológiai, társadalmi és technológiai feltétel tökéletes és megismételhetetlen konvergenciájával, a digitális éterben megszületett az a szingularitás, amely elkerülhetetlenül és végérvényesen létrehozta azt a közösségi entitást, amelyre az univerzum a kezdetek óta várt: az UMKGL Discord szervert.
                </p>
              </div>
              <button id="summaryCloseBtn" type="button" class="summary-card__close">
                Összefoglaló bezárása
              </button>
            </article>
          </div>
        </div>
      </section>

      <section id="fajlkuldes">
        <div class="transfer-header">
          <div>
            <h2>P2P Fájlküldés</h2>
            <p class="transfer-subtitle">Valós idejű radar és részletes átviteli státuszok.</p>
          </div>
          <label class="switch-control">
            <input type="checkbox" id="receiverToggle" />
            <span>Fogadó mód bekapcsolása</span>
          </label>
        </div>
        <p id="receiverStatus" class="transfer-status">Csatlakozz bejelentkezés után a fogadó módhoz.</p>

        <div class="transfer-dashboard">
          <div class="transfer-radar">
            <div class="transfer-panel__header">
              <div>
                <h3>Radar nézet</h3>
                <p>Kattints egy partnerre a küldéshez.</p>
              </div>
            </div>
            <div class="radar-container">
              <div class="radar-viewport" id="radarViewport">
                <div class="radar-world" id="radarWorld">
                  <div class="radar-peers" id="receiverList"></div>
                  <div class="radar-center">
                    <div class="ripple"></div>
                    <div class="ripple ripple-delay"></div>
                    <div class="self-avatar">
                      <img id="selfAvatar" src="program_icons/default-avatar.png" alt="Saját avatar" />
                      <span id="selfLabel" class="self-label">Te</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="transfer-panel">
            <div class="transfer-panel__header">
              <div>
                <h3>Fájlátvitelek</h3>
                <p>Bejövő és kimenő fájlok részletesen</p>
              </div>
            </div>
            <div id="transferList" class="transfer-list">
              <div class="transfer-empty">Nincsenek aktív átviteli feladatok.</div>
            </div>
          </div>
        </div>

        <input type="file" id="p2pFileInput" style="display: none;" />
      </section>

      <section id="klipek">
        <div id="clipsPermissionOverlay" class="permission-overlay" aria-hidden="true">
          <div class="permission-overlay__content">
            <h3>Klipek csak jogosultsággal elérhetők</h3>
            <p>Jelentkezz be, és kérj engedélyt egy admintól a megtekintéshez.</p>
          </div>
        </div>
        <div class="clips-content">
          <div class="clips-header">
            <div>
              <h2>Klipek</h2>
              <p>Fedezd fel a legújabb videókat, szűrj címkék és dátum szerint.</p>
            </div>
            <button id="showUploadModalBtn" class="primary-button">Feltöltés</button>
          </div>

          <div class="clip-filters">
            <div class="filter-group">
              <label for="videoSearchInput">Keresés cím vagy fájlnév alapján</label>
              <input id="videoSearchInput" type="search" placeholder="Pl. epikus csata" />
            </div>
            <div class="filter-group">
              <label for="tagFilterSelect">Címke</label>
              <select id="tagFilterSelect">
                <option value="">Összes címke</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="sortOrderSelect">Rendezés</label>
              <select id="sortOrderSelect">
                <option value="newest">Legújabb elöl</option>
                <option value="oldest">Legrégebbi elöl</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="videoQualitySelect">Minőség</label>
              <select id="videoQualitySelect">
                <option value="1080p">Eredeti (1080p)</option>
                <option value="720p">HD (720p)</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="pageSizeSelect">Videók száma / oldal</label>
              <select id="pageSizeSelect">
                <option value="12">12</option>
                <option value="24" selected>24</option>
                <option value="40">40</option>
                <option value="80">80</option>
              </select>
            </div>
            <div class="filter-group filter-group--actions">
              <label class="sr-only" for="filterResetBtn">Szűrők törlése</label>
              <button id="filterResetBtn" class="secondary-btn">Szűrők törlése</button>
            </div>
          </div>

          <div id="video-grid-container"></div>
          <div id="video-pagination" class="pagination"></div>

          <div id="clipToast" class="upload-toast clip-toast" aria-live="polite"></div>

          <div id="uploadModal" class="modal-overlay" style="display: none;">
            <div class="upload-modal-content">
              <div class="upload-modal-header">
                <h3 class="upload-modal-title">Videó feltöltése</h3>
                <button class="close-btn" id="closeUploadModal" aria-label="Bezárás">&times;</button>
              </div>

              <div class="upload-modal-toolbar">
                <button class="primary-btn" id="addFilesBtn">Fájlok hozzáadása</button>
                <div class="toolbar-tags">
                  <label for="globalTagSelect">Címkék mindhez</label>
                  <select id="globalTagSelect" multiple size="8"></select>
                </div>
                <div id="createTagWrapper" style="display: none;">
                  <div class="create-tag-row">
                    <div class="tag-field-group">
                      <input
                        type="text"
                        id="newTagName"
                        placeholder="Új címke neve"
                        class="new-tag-input"
                      />
                      <button id="tagColorButton" type="button" class="tag-color-button">
                        <span class="tag-color-swatch"></span>
                        Szín
                      </button>
                    </div>
                    <div class="tag-action-group">
                      <button id="deleteTagButton" type="button" class="danger-btn">Törlés</button>
                      <button id="createTagButton" type="button">Hozzáadás</button>
                    </div>
                    <input type="color" id="newTagColor" class="tag-color-input" value="#5865f2" />
                  </div>
                  <small id="createTagStatus"></small>
                </div>
              </div>

              <input type="file" id="fileInput" accept="video/*" style="display: none;" multiple />

              <div id="uploadQueueContainer" class="upload-queue-container">
                <div id="drop-zone" class="drop-zone">
                  <p>Húzd ide a videóidat vagy kattints a tallózáshoz</p>
                  <p id="selectedFileName">Nincs kiválasztott fájl.</p>
                </div>
              </div>

              <div id="uploadToast" class="upload-toast" aria-live="polite"></div>

              <div class="upload-modal-footer">
                <div>
                  <div id="uploadSummary" class="upload-summary">Nincs kiválasztott fájl.</div>
                  <p id="uploadStatus" class="upload-status"></p>
                  <div id="uploadProgress" class="upload-progress" style="display: none">
                    <div class="upload-progress__bar">
                      <div id="uploadProgressFill" class="upload-progress__fill"></div>
                    </div>
                    <div class="upload-progress__meta">
                      <span id="uploadProgressCount">0 / 0 klip</span>
                      <span id="uploadProgressEta">Hátralévő idő: --</span>
                    </div>
                    <div id="uploadProgressDetails" class="upload-progress__details"></div>
                  </div>
                </div>
                <div class="upload-action-buttons">
                  <button id="cancelUploadBtn" class="secondary-btn large" type="button">Mégse</button>
                  <button id="uploadBtn" class="primary-btn large" disabled>FELTÖLTÉS</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Hoi4 Sorsolás -->
      <section id="sorsolas">
        <h1>HOI4 Road to 56 – Sorsoló</h1>

        <div class="controls-top">
          <button id="resetAllBtn">Teljes Sorsolás Visszaállítása</button>
        </div>

        <div class="options-panel">
          <label for="balanceCountriesByStrength">
            <input type="checkbox" id="balanceCountriesByStrength" checked />
            Országok erősségalapú kiegyensúlyozása a csapatok között
          </label>
        </div>

        <div class="last-picked-display">
          Legutóbb: Játékos: <span id="lastPickedPlayer">-</span> | Ország:
          <span id="lastPickedCountry">-</span>
        </div>

        <div id="spinResultOverlay" class="spin-result-overlay">
          <div id="spunItemDisplay" class="spun-item-display">Kipörgetve: -</div>
          <button id="nextSpinStepButton" class="next-spin-step-button">
            Következő
          </button>
        </div>

        <div class="flex">
          <div class="box">
            <h2>
              Játékosok <span class="count-display" id="playerListCount">(0)</span>
            </h2>
            <input id="playerName" type="text" placeholder="Név" />
            <input
              id="playerSkill"
              type="number"
              placeholder="Képesség 1–10"
              min="1"
              max="10"
            />
            <button id="addPlayerBtn" onclick="handlePlayerSubmit()">
              Hozzáadás
            </button>
            <ul id="playersList"></ul>
          </div>

          <div class="box">
            <h2>
              Országok <span class="count-display" id="countryListCount">(0)</span>
            </h2>
            <input id="countryName" type="text" placeholder="Ország neve" />
            <input
              id="countryStrength"
              type="number"
              placeholder="Erősség 1-10"
              min="1"
              max="10"
            />
            <button id="addCountryBtn" onclick="handleCountrySubmit()">
              Hozzáadás
            </button>
            <ul id="countriesList"></ul>
          </div>

          <div class="box">
            <h2>Csapatok</h2>
            <div id="teamWheelContainer" class="wheel-container">
              <div class="pointer">◄</div>
              <canvas id="teamWheel" width="250" height="250"></canvas>
            </div>
            <button id="spinTeamBtn">Csapat osztás / Forgatás</button>
            <h3>
              Csapat 1 játékosok
              <span class="count-display" id="team1PlayerCount">(0)</span>
            </h3>
            <ul id="playerBasket1" class="player-basket"></ul>
            <h3>
              Csapat 2 játékosok
              <span class="count-display" id="team2PlayerCount">(0)</span>
            </h3>
            <ul id="playerBasket2" class="player-basket"></ul>
          </div>

          <div class="box">
            <h2>
              Országok <span class="count-display" id="countryBoxCount">(0)</span>
            </h2>
            <div id="countryWheelContainer" class="wheel-container">
              <div class="pointer">◄</div>
              <canvas id="countryWheel" width="250" height="250"></canvas>
            </div>
            <button id="spinCountryBtn">Ország osztás / Forgatás</button>

            <div id="countryGridsContainer">
              <div class="team-grid-wrapper" id="team1CountryGridWrapper">
                <h3>
                  Csapat 1 országok
                  <span class="count-display" id="team1CountryCount">(0/9)</span>
                  <button
                    class="grid-zoom-btn"
                    data-targetwrapper="team1CountryGridWrapper"
                    title="Nagyítás/Kicsinyítés"
                  >
                    🔍
                  </button>
                </h3>
                <div id="countrySlots1" class="basket-grid"></div>
              </div>
              <div class="team-grid-wrapper" id="team2CountryGridWrapper">
                <h3>
                  Csapat 2 országok
                  <span class="count-display" id="team2CountryCount">(0/9)</span>
                  <button
                    class="grid-zoom-btn"
                    data-targetwrapper="team2CountryGridWrapper"
                    title="Nagyítás/Kicsinyítés"
                  >
                    🔍
                  </button>
                </h3>
                <div id="countrySlots2" class="basket-grid"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Szavazás -->
      <section id="szavazas">
        <h2>Szavazások</h2>
        <div id="pollCreator" class="poll-card">
          <h3>Új szavazás létrehozása</h3>
          <p id="pollCreatorNotice" class="poll-hint"></p>
          <form id="createPollForm">
            <input
              id="questionInput"
              class="poll-text-input"
              type="text"
              placeholder="Kérdés"
              required
            />
            <div id="optionsContainer" class="poll-options-inputs"></div>
            <div class="poll-creator-actions">
              <button type="button" id="addOptionBtn" class="poll-button poll-secondary-btn">
                Új válaszlehetőség
              </button>
              <button type="submit" class="poll-button poll-primary-btn">
                Szavazás létrehozása
              </button>
            </div>
          </form>
        </div>
        <div id="pollList" class="poll-list"></div>
      </section>

<!-- Programok -->
      <section id="programok">
        <div class="programs-header">
          <div>
            <h2>Programok</h2>
            <p class="programs-subtitle">Letölthető eszközök és programok a közösség számára.</p>
          </div>
          <button id="addProgramBtn" class="primary-button" type="button" style="display: none;">Új Program Hozzáadása</button>
        </div>
        <div id="programsContainer" class="program-grid"></div>
      </section>

      <section id="admin">
        <h2>Felhasználók Kezelése</h2>
        <p class="admin-description">
          Állítsd be felhasználónként, hogy ki tölthet fel, valamint a feltöltésekhez tartozó méret- és darabkorlátokat.
        </p>
        <div id="userListContainer"></div>
        <button id="savePermissionsBtn">Változtatások Mentése</button>

        <div class="admin-clips-actions">
          <button id="loadClipsBtn" class="secondary-btn" type="button">Klip lista megnyitása</button>
          <button id="processingStatusBtn" class="secondary-btn" type="button">Feldolgozási állapot</button>
        </div>
      </section>

      <section id="profile">
        <h2>Profil Beállítások</h2>
        <div class="profile-grid">
          <div class="profile-card">
            <h3>Profilkép</h3>
            <p>Tölts fel egy egyedi avatárt, hogy mindenki felismerjen.</p>
            <div class="profile-avatar-wrapper">
              <img id="profileAvatarPreview" class="profile-avatar-preview" src="program_icons/default-avatar.png" alt="Profile Avatar">
              <div class="profile-actions">
                <label class="ghost-button" for="avatarInput">Fájl kiválasztása</label>
                <input type="file" id="avatarInput" accept="image/png, image/jpeg, image/jpg, image/gif" style="display: none;">
                <button id="uploadAvatarBtn" class="primary-button" type="button">Feltöltés</button>
              </div>
              <p id="avatarUploadStatus" class="profile-status"></p>
            </div>
          </div>

          <div class="profile-card">
            <h3>Név módosítása</h3>
            <p>Állítsd be az új megjelenítendő neved.</p>
            <form id="updateUsernameForm">
              <input type="text" id="newUsername" class="profile-input" placeholder="Új felhasználónév" required>
              <button type="submit" class="primary-button">Mentés</button>
            </form>
          </div>

          <div class="profile-card">
            <h3>Biztonság</h3>
            <p>Frissítsd a jelszavad a biztonság érdekében.</p>
            <form id="updatePasswordForm">
              <input type="password" id="currentPassword" class="profile-input" placeholder="Jelenlegi jelszó" required>
              <input type="password" id="newPassword" class="profile-input" placeholder="Új jelszó" required>
              <button type="submit" class="primary-button">Jelszó cseréje</button>
            </form>
          </div>
        </div>
      </section>
    </main>

    <div id="avatarCropperModal" class="avatar-cropper-modal" aria-hidden="true">
      <div class="avatar-cropper-dialog" role="dialog" aria-modal="true" aria-labelledby="avatarCropperTitle">
        <div class="avatar-cropper-header">
          <h3 id="avatarCropperTitle">Kép szerkesztése</h3>
        </div>
        <div class="avatar-cropper-body">
          <div class="avatar-cropper-canvas">
            <img id="avatarCropperImage" src="" alt="Avatar kivágás" />
          </div>
          <div class="avatar-zoom-control">
            <span class="zoom-icon" aria-hidden="true">🖼️</span>
            <input
              type="range"
              id="avatarZoomRange"
              class="avatar-zoom-range"
              min="0.5"
              max="3"
              step="0.01"
              value="1"
              aria-label="Nagyítás"
            />
            <span class="zoom-icon" aria-hidden="true" style="font-size: 1.1rem;">🖼️</span>
          </div>
        </div>
        <div class="avatar-cropper-footer">
          <button type="button" id="avatarCropperCancel" class="ghost-button">Mégse</button>
          <button type="button" id="avatarCropperSave" class="primary-button">Mentés</button>
        </div>
      </div>
    </div>

    <footer>
      <p>© 2025 UMKGL HUB Minden jog fenntartva</p>
    </footer>

    <div id="videoPlayerModal" class="video-modal" aria-hidden="true">
      <div class="video-modal__inner" role="dialog" aria-modal="true" aria-label="Videólejátszó">
        <button type="button" class="video-modal__close" id="closeVideoModalBtn" aria-label="Bezárás">
          &times;
        </button>
        <div class="video-modal__content">
          <video id="modalVideoPlayer" class="video-modal__video" controls autoplay></video>
          <p id="modalVideoTitle" class="video-modal__title"></p>
        </div>
        <div class="video-modal__nav-wrapper">
          <button
            type="button"
            class="video-modal__nav video-modal__nav--prev"
            id="prevVideoBtn"
            aria-label="Előző videó"
          >
            &#10094;
          </button>
          <button
            type="button"
            class="video-modal__nav video-modal__nav--next"
            id="nextVideoBtn"
            aria-label="Következő videó"
          >
            &#10095;
          </button>
        </div>
      </div>
    </div>

  <script>
    const ADMIN_SESSION_KEY = "isAdmin";
    const ADMIN_ONLY_SECTIONS = new Set(["admin"]);
    const loginModal = document.getElementById("loginModal");
    const closeLogin = document.getElementById("closeLogin");
    const loginForm = document.getElementById("loginForm");
    const loginBtn = document.getElementById("loginBtn");
    const registerBtn = document.getElementById("registerBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authLoggedOut = document.getElementById("authLoggedOut");
    const authLoggedIn = document.getElementById("authLoggedIn");
    const userGreeting = document.getElementById("userGreeting");
    const adminNavBtn = document.getElementById("adminNavBtn");
    const programNavBtn = document.getElementById("programNavBtn");
    const fileTransferNavBtn = document.getElementById("fileTransferNavBtn");
    const userListContainer = document.getElementById("userListContainer");
    const savePermissionsBtn = document.getElementById("savePermissionsBtn");
    const loadClipsBtn = document.getElementById("loadClipsBtn");
    const processingStatusBtn = document.getElementById("processingStatusBtn");
    const pollCreator = document.getElementById("pollCreator");
    const pollCreatorNotice = document.getElementById("pollCreatorNotice");
    const createPollForm = document.getElementById("createPollForm");
    const questionInput = document.getElementById("questionInput");
    const optionsContainer = document.getElementById("optionsContainer");
    const addOptionBtn = document.getElementById("addOptionBtn");
    const pollListContainer = document.getElementById("pollList");
    const pollSection = document.getElementById("szavazas");
    const receiverToggle = document.getElementById("receiverToggle");
    const receiverList = document.getElementById("receiverList");
    const selfAvatar = document.getElementById("selfAvatar");
    const selfLabel = document.getElementById("selfLabel");
    const radarViewport = document.getElementById("radarViewport");
    const radarWorld = document.getElementById("radarWorld");
    const receiverStatus = document.getElementById("receiverStatus");
    const uploadAvatarBtn = document.getElementById('uploadAvatarBtn');
    const avatarInput = document.getElementById('avatarInput');
    const avatarUploadStatus = document.getElementById('avatarUploadStatus');
    const profileAvatarPreview = document.getElementById('profileAvatarPreview');
    const p2pFileInput = document.getElementById("p2pFileInput");
    const transferList = document.getElementById("transferList");
    const programsContainer = document.getElementById("programsContainer");
    const addProgramBtn = document.getElementById("addProgramBtn");
    const programUploadModal = document.getElementById("programUploadModal");
    const programUploadTitle = document.getElementById("programUploadTitle");
    const programUploadForm = document.getElementById("programUploadForm");
    const programNameInput = document.getElementById("programNameInput");
    const programDescriptionInput = document.getElementById("programDescriptionInput");
    const programImageInput = document.getElementById("programImageInput");
    const programFileInput = document.getElementById("programFileInput");
    const programImagePreview = document.getElementById("programImagePreview");
    const programFileName = document.getElementById("programFileName");
    const closeProgramUploadModalBtn = document.getElementById("closeProgramUploadModal");
    const cancelProgramUploadBtn = document.getElementById("cancelProgramUploadBtn");
    const submitProgramUploadBtn = document.getElementById("submitProgramUploadBtn");

    const SESSION_KEYS = {
      token: "token",
      username: "username",
      isAdmin: ADMIN_SESSION_KEY,
      canTransfer: "canTransfer",
      canViewClips: "canViewClips",
      profilePictureFilename: "profilePictureFilename",
    };
    const POLL_MIN_OPTIONS = 2;
    let pollsShouldRefresh = true;
    let programImageCropper = null;
    let programImageObjectUrl = null;
    let editingProgram = null;

    function isPollSectionActive() {
      return pollSection?.classList.contains("active");
    }

    function refreshPollsIfVisible() {
      if (!isPollSectionActive() || !pollsShouldRefresh) {
        return;
      }

      pollsShouldRefresh = false;
      loadPolls();
    }

    function markPollsForRefresh() {
      pollsShouldRefresh = true;
      refreshPollsIfVisible();
    }

    const transfers = new Map();
    const RECEIVER_TOGGLE_KEY = "receiverToggleState";
    let peer = null;
    let socket = null;
    let peerId = null;
    let selectedReceiver = null;
    const radarPanState = {
      offsetX: 0,
      offsetY: 0,
      startX: 0,
      startY: 0,
      isDragging: false,
      scale: 1,
      minScale: 0.6,
      maxScale: 2.5,
      zoomStep: 0.12,
    };

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function updateSelfLabelText(name) {
      if (!selfLabel) {
        return;
      }

      const username = name || localStorage.getItem(SESSION_KEYS.username);
      selfLabel.textContent = username || "Te";
    }

    function applyRadarPan() {
      if (!radarWorld) {
        return;
      }

      radarWorld.style.transform = `translate(-50%, -50%) translate(${radarPanState.offsetX}px, ${radarPanState.offsetY}px) scale(${radarPanState.scale})`;
    }

    function setupRadarPanning() {
      if (!radarViewport || !radarWorld) {
        return;
      }

      const startPan = (event) => {
        radarPanState.isDragging = true;
        radarViewport.classList.add("is-grabbing");
        radarPanState.startX = event.clientX - radarPanState.offsetX;
        radarPanState.startY = event.clientY - radarPanState.offsetY;
        event.preventDefault();
      };

      const handlePanMove = (event) => {
        if (!radarPanState.isDragging) {
          return;
        }

        radarPanState.offsetX = event.clientX - radarPanState.startX;
        radarPanState.offsetY = event.clientY - radarPanState.startY;
        applyRadarPan();
      };

      const endPan = () => {
        if (!radarPanState.isDragging) {
          return;
        }

        radarPanState.isDragging = false;
        radarViewport.classList.remove("is-grabbing");
      };

      radarViewport.addEventListener("mousedown", startPan);
      window.addEventListener("mousemove", handlePanMove);
      window.addEventListener("mouseup", endPan);

      applyRadarPan();
    }

    function setupRadarZoom() {
      if (!radarViewport || !radarWorld) {
        return;
      }

      const handleWheel = (event) => {
        event.preventDefault();

        const direction = event.deltaY < 0 ? 1 : -1;
        const scaleChange = direction * radarPanState.zoomStep;
        const newScale = clamp(
          radarPanState.scale + scaleChange,
          radarPanState.minScale,
          radarPanState.maxScale,
        );

        if (newScale === radarPanState.scale) {
          return;
        }

        const rect = radarViewport.getBoundingClientRect();
        const offsetFromCenterX = event.clientX - rect.left - rect.width / 2;
        const offsetFromCenterY = event.clientY - rect.top - rect.height / 2;

        radarPanState.offsetX -= offsetFromCenterX * (newScale - radarPanState.scale);
        radarPanState.offsetY -= offsetFromCenterY * (newScale - radarPanState.scale);

        radarPanState.scale = newScale;
        applyRadarPan();
      };

      radarViewport.addEventListener("wheel", handleWheel, { passive: false });
    }

    function decodeTokenPayload(token) {
      try {
        const payload = token.split(".")[1];
        return JSON.parse(atob(payload));
      } catch (error) {
        return null;
      }
    }

    function getCurrentUserId() {
      const token = getStoredToken();
      const payload = token ? decodeTokenPayload(token) : null;
      return payload && payload.id ? Number(payload.id) : null;
    }

    function updateReceiverStatus(message) {
      if (receiverStatus) {
        receiverStatus.textContent = message;
      }
    }

    function formatFileSize(size) {
      if (!Number.isFinite(size)) {
        return "Ismeretlen";
      }
      if (size >= 1024 * 1024) {
        return `${(size / (1024 * 1024)).toFixed(2)} MB`;
      }
      if (size >= 1024) {
        return `${(size / 1024).toFixed(2)} KB`;
      }
      return `${size} B`;
    }

    function formatDateTime(value) {
      if (!value) {
        return "Ismeretlen dátum";
      }

      const date = new Date(value);
      if (Number.isNaN(date.getTime())) {
        return "Ismeretlen dátum";
      }

      return date.toLocaleString("hu-HU");
    }

    function formatSpeed(bytesPerSecond) {
      if (!Number.isFinite(bytesPerSecond) || bytesPerSecond <= 0) {
        return "0 MB/s";
      }
      return `${(bytesPerSecond / (1024 * 1024)).toFixed(2)} MB/s`;
    }

    function formatEta(remainingBytes, speedBps) {
      if (!Number.isFinite(remainingBytes) || !Number.isFinite(speedBps) || speedBps <= 0) {
        return "∞";
      }
      const seconds = remainingBytes / speedBps;
      if (seconds < 1) {
        return "<1 s";
      }
      const minutes = Math.floor(seconds / 60);
      const secs = Math.round(seconds % 60);
      if (minutes > 0) {
        return `${minutes}m ${secs}s`;
      }
      return `${secs}s`;
    }

    function ensureTransferPlaceholder() {
      if (!transferList) {
        return;
      }
      const hasCards = transferList.querySelector(".transfer-card");
      if (!hasCards && !transferList.querySelector(".transfer-empty")) {
        const placeholder = document.createElement("div");
        placeholder.className = "transfer-empty";
        placeholder.textContent = "Nincsenek aktív átviteli feladatok.";
        transferList.appendChild(placeholder);
      }
      if (hasCards) {
        transferList.querySelectorAll(".transfer-empty").forEach((el) => el.remove());
      }
    }

    function createTransferCard({ id, direction, name, size, mimeType, status }) {
      if (!transferList) {
        return null;
      }

      const card = document.createElement("article");
      card.className = "transfer-card";
      card.dataset.transferId = id;

      const header = document.createElement("div");
      header.className = "transfer-card__header";

      const icon = document.createElement("div");
      icon.className = `transfer-card__icon transfer-card__icon--${direction}`;
      icon.textContent = direction === "incoming" ? "⬇" : "⬆";

      const meta = document.createElement("div");
      meta.className = "transfer-card__meta";

      const filename = document.createElement("div");
      filename.className = "transfer-card__filename";
      filename.textContent = name || "Ismeretlen";

      const fileInfo = document.createElement("div");
      fileInfo.className = "transfer-card__filesize";
      fileInfo.textContent = `${formatFileSize(size)} • ${mimeType || "Ismeretlen"}`;

      meta.appendChild(filename);
      meta.appendChild(fileInfo);
      header.appendChild(icon);
      header.appendChild(meta);

      const statusEl = document.createElement("p");
      statusEl.className = "transfer-card__status";
      statusEl.textContent = status;

      const progress = document.createElement("div");
      progress.className = "transfer-progress";
      const progressFill = document.createElement("div");
      progressFill.className = "transfer-progress__fill";
      progress.appendChild(progressFill);

      const stats = document.createElement("div");
      stats.className = "transfer-stats";
      const speedEl = document.createElement("span");
      speedEl.textContent = "0 MB/s";
      const etaEl = document.createElement("span");
      etaEl.textContent = "ETA: ∞";
      stats.appendChild(speedEl);
      stats.appendChild(etaEl);

      const actions = document.createElement("div");
      actions.className = "transfer-actions";

      card.appendChild(header);
      card.appendChild(statusEl);
      card.appendChild(progress);
      card.appendChild(stats);
      card.appendChild(actions);

      transferList.prepend(card);
      ensureTransferPlaceholder();

      const transfer = {
        id,
        direction,
        name,
        size,
        mimeType,
        statusEl,
        progressFill,
        speedEl,
        etaEl,
        actions,
        card,
        conn: null,
        file: null,
        received: 0,
        chunks: [],
        startTime: null,
        isCancelled: false,
        completed: false,
      };

      transfers.set(id, transfer);
      return transfer;
    }

    function updateTransferStatus(transfer, text) {
      if (transfer?.statusEl) {
        transfer.statusEl.textContent = text;
      }
    }

    function updateTransferProgress(transfer, transferredBytes, totalBytes) {
      if (!transfer) {
        return;
      }
      if (Number.isFinite(transferredBytes) && Number.isFinite(totalBytes) && totalBytes > 0) {
        const percent = Math.min(100, Math.round((transferredBytes / totalBytes) * 100));
        if (transfer.progressFill) {
          transfer.progressFill.style.width = `${percent}%`;
        }
      }

      if (transfer.startTime) {
        const elapsedSeconds = (Date.now() - transfer.startTime) / 1000;
        const speedBps = elapsedSeconds > 0 ? transferredBytes / elapsedSeconds : 0;
        if (transfer.speedEl) {
          transfer.speedEl.textContent = formatSpeed(speedBps);
        }
        if (transfer.etaEl && Number.isFinite(totalBytes)) {
          const remaining = Math.max(0, totalBytes - transferredBytes);
          transfer.etaEl.textContent = `ETA: ${formatEta(remaining, speedBps)}`;
        }
      }
    }

    function finalizeTransfer(transfer, statusText) {
      updateTransferStatus(transfer, statusText);
      if (transfer?.actions) {
        transfer.actions.querySelectorAll("button").forEach((btn) => (btn.disabled = true));
      }
      if (transfer) {
        transfer.completed = true;
      }
      ensureTransferPlaceholder();
    }

    function setTransferActions(transfer, buttons = []) {
      if (!transfer?.actions) {
        return;
      }
      transfer.actions.innerHTML = "";
      buttons.forEach((btn) => transfer.actions.appendChild(btn));
    }

    function createTransferButton(label, className, onClick) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = `transfer-btn ${className}`;
      btn.textContent = label;
      if (onClick) {
        btn.addEventListener("click", onClick);
      }
      return btn;
    }

    function getTransferByConn(conn) {
      if (!conn?.__transferId) {
        return null;
      }
      return transfers.get(conn.__transferId) || null;
    }

    function clearTransfers() {
      transfers.clear();
      if (transferList) {
        transferList.innerHTML = "";
      }
      ensureTransferPlaceholder();
    }

    function clearReceiverList() {
      if (receiverList) {
        receiverList.innerHTML = "";
      }
    }

    function handleReceiversUpdate(list) {
      if (!receiverList) {
        return;
      }

      const currentUserId = getCurrentUserId();
      receiverList.innerHTML = "";

      if (!Array.isArray(list) || list.length === 0) {
        const empty = document.createElement("div");
        empty.className = "radar-empty";
        empty.textContent = "Nincs aktív fogadó.";
        receiverList.appendChild(empty);
        return;
      }

      const peers = list.filter((item) => item.userId !== currentUserId);
      if (!peers.length) {
        const empty = document.createElement("div");
        empty.className = "radar-empty";
        empty.textContent = "Nincs elérhető másik fogadó.";
        receiverList.appendChild(empty);
        return;
      }

      const radius = 250;
      peers.forEach((item, index) => {
        const angle = (2 * Math.PI * index) / peers.length - Math.PI / 2;
        const offsetY = radius * Math.sin(angle);
        const offsetX = radius * Math.cos(angle);
        const avatarUrl = item.profile_picture_filename
          ? `/uploads/avatars/${item.profile_picture_filename}`
          : "program_icons/default-avatar.png";

        const bubble = document.createElement("button");
        bubble.type = "button";
        bubble.className = "peer-avatar";
        bubble.dataset.peerId = item.peerId;
        bubble.dataset.username = item.username;
        bubble.style.top = `calc(50% + ${offsetY}px)`;
        bubble.style.left = `calc(50% + ${offsetX}px)`;
        bubble.style.transform = "translate(-50%, -50%)";

        const img = document.createElement("img");
        img.src = avatarUrl;
        img.alt = `${item.username} avatar`;
        bubble.appendChild(img);

        const name = document.createElement("span");
        name.className = "peer-name";
        name.textContent = item.username;
        bubble.appendChild(name);

        receiverList.appendChild(bubble);
      });
    }

    function ensureSocketConnection() {
      if (socket || !isUserLoggedIn()) {
        return;
      }

      socket = io({
        auth: { token: getStoredToken() },
        transports: ["websocket"],
        upgrade: false,
      });

      socket.on("connect", () => {
        updateReceiverStatus("Kapcsolódva a jelző szerverhez.");
        registerReceiverIfEnabled();
      });

      socket.on("connect_error", (err) => {
        console.error("Socket csatlakozási hiba:", err);
        updateReceiverStatus("Nem sikerült kapcsolódni a szerverhez (Socket hiba).");
      });

      socket.on("update_receivers_list", (list) => {
        handleReceiversUpdate(list);
      });

      socket.on("receiver_error", (payload) => {
        const message = payload && payload.message ? payload.message : "Ismeretlen hiba.";
        updateReceiverStatus(message);
      });

      socket.on("disconnect", () => {
        clearReceiverList();
        updateReceiverStatus("Kapcsolat bontva a jelző szerverrel.");
      });
    }

    function ensurePeerConnection() {
      if (peer || !isUserLoggedIn()) {
        return;
      }

      peer = new Peer({
        config: {
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" },
            { urls: "stun:stun3.l.google.com:19302" },
            { urls: "stun:stun4.l.google.com:19302" },
            { urls: "stun:stun.framasoft.org" },
            { urls: "stun:stun.voip.blackberry.com:3478" },
            { urls: "stun:stun.antisip.com" },
            { urls: "stun:stun.sipgate.net" },
            { urls: "stun:openrelay.metered.ca:80" },
          ],
          iceCandidatePoolSize: 10,
        },
      });
      peer.on("open", (id) => {
        peerId = id;
        registerReceiverIfEnabled();
      });

      peer.on("connection", handleIncomingConnection);

      peer.on("disconnected", () => {
        peerId = null;
      });
    }

    function initializeRealtimeFeatures() {
      ensureSocketConnection();
      ensurePeerConnection();
    }

    function setupFileTransferUI() {
      setupRadarPanning();
      setupRadarZoom();
      updateSelfLabelText();

      if (receiverToggle) {
        const savedToggle = localStorage.getItem(RECEIVER_TOGGLE_KEY) === "true";
        receiverToggle.checked = savedToggle;

        receiverToggle.addEventListener("change", () => {
          localStorage.setItem(RECEIVER_TOGGLE_KEY, receiverToggle.checked ? "true" : "false");

          if (!isUserLoggedIn()) {
            updateReceiverStatus("A fogadó mód használatához jelentkezz be.");
            receiverToggle.checked = false;
            return;
          }

          initializeRealtimeFeatures();
          if (receiverToggle.checked) {
            registerReceiverIfEnabled();
          } else if (socket) {
            socket.emit("unregister_receiver");
            updateReceiverStatus("Fogadó mód kikapcsolva.");
          }
        });

        if (savedToggle && isUserLoggedIn()) {
          initializeRealtimeFeatures();
          registerReceiverIfEnabled();
        }
      }

      if (receiverList) {
        receiverList.addEventListener("click", (event) => {
          const btn = event.target.closest("button[data-peer-id]");
          if (!btn) {
            return;
          }

          if (!isUserLoggedIn()) {
            updateReceiverStatus("A fájlküldéshez jelentkezz be.");
            return;
          }

          initializeRealtimeFeatures();
          selectedReceiver = {
            peerId: btn.dataset.peerId,
            username: btn.dataset.username,
          };
          if (p2pFileInput) {
            p2pFileInput.click();
          }
        });
      }

      if (p2pFileInput) {
        p2pFileInput.addEventListener("change", (event) => {
          const file = event.target.files[0];
          if (!file || !selectedReceiver) {
            return;
          }
          initializeRealtimeFeatures();
          startFileSend(selectedReceiver, file);
          event.target.value = "";
        });
      }

      ensureTransferPlaceholder();
    }

    setupFileTransferUI();

    function teardownRealtimeFeatures() {
      if (socket) {
        socket.emit("unregister_receiver");
        socket.disconnect();
        socket = null;
      }
      if (peer) {
        peer.destroy();
        peer = null;
      }
      peerId = null;
      selectedReceiver = null;
      clearTransfers();
      clearReceiverList();
      if (receiverToggle) {
        receiverToggle.checked = false;
      }
    }

    function registerReceiverIfEnabled() {
      if (!receiverToggle || !receiverToggle.checked || !socket || !peerId || !isUserLoggedIn()) {
        return;
      }

      socket.emit("register_receiver", { token: getStoredToken(), peerId });
      updateReceiverStatus("Fogadó mód aktiválva.");
    }

    function handleIncomingConnection(conn) {
      conn.on("data", async (data) => {
        if (!data || typeof data !== "object") {
          return;
        }

        console.log("P2P adat érkezett", data.type, data);

        let transfer = getTransferByConn(conn);

        if (data.type === "meta") {
          const transferId = `incoming-${Date.now()}-${Math.random().toString(16).slice(2)}`;
          transfer = createTransferCard({
            id: transferId,
            direction: "incoming",
            name: data.name,
            size: data.size,
            mimeType: data.mimeType,
            status: "Várakozás elfogadásra...",
          });

          if (!transfer) {
            return;
          }

          transfer.conn = conn;
          conn.__transferId = transferId;

          const cancelBtn = createTransferButton("Mégse", "transfer-btn--cancel", () => {
            transfer.isCancelled = true;
            conn.send({ type: "cancel" });
            finalizeTransfer(transfer, "Fogadás megszakítva.");
            conn.close();
          });

          const acceptBtn = createTransferButton("Elfogad (Letöltés)", "transfer-btn--accept", () => {
            transfer.startTime = Date.now();
            transfer.received = 0;
            transfer.chunks = [];
            updateTransferStatus(transfer, "Fogadás...");
            setTransferActions(transfer, [cancelBtn]);
            conn.send({ type: "accept" });
            console.log("Accept üzenet elküldve a küldőnek");
          });

          const rejectBtn = createTransferButton("Elutasít", "transfer-btn--reject", () => {
            transfer.isCancelled = true;
            conn.send({ type: "reject" });
            finalizeTransfer(transfer, "A fájlátvitel elutasítva.");
            console.log("Reject üzenet elküldve a küldőnek");
            conn.close();
          });

          setTransferActions(transfer, [acceptBtn, rejectBtn]);
          updateTransferStatus(transfer, "Várakozás elfogadásra...");

          return;
        }

        if (!transfer) {
          return;
        }

        if (data.type === "chunk") {
          if (transfer.isCancelled) {
            return;
          }
          if (!transfer.startTime) {
            transfer.startTime = Date.now();
          }

          const chunkBuffer =
            data.data instanceof ArrayBuffer
              ? data.data
              : data.data?.buffer instanceof ArrayBuffer
                ? data.data.buffer
                : null;

          if (!chunkBuffer) {
            console.warn("Érvénytelen chunk érkezett, kihagyva.");
            return;
          }

          transfer.chunks.push(chunkBuffer);
          transfer.received += chunkBuffer.byteLength;

          if (transfer.size) {
            const percent = Math.min(100, Math.round((transfer.received / transfer.size) * 100));
            updateTransferStatus(transfer, `Fogadás: ${percent}%`);
          } else {
            updateTransferStatus(transfer, "Fogadás...");
          }

          updateTransferProgress(transfer, transfer.received, transfer.size || transfer.received);
          return;
        }

        if (data.type === "complete") {
          if (typeof transfer.size === "number" && transfer.received !== transfer.size) {
            console.error(
              "Átvitel sikertelen: a beérkezett méret nem egyezik a metaadatban lévő mérettel.",
            );
            finalizeTransfer(transfer, "Hiba: a fájl mérete nem stimmel, letöltés megszakítva.");
            return;
          }

          const blob = new Blob(transfer.chunks, {
            type: transfer.mimeType || "application/octet-stream",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = transfer.name || "fajl";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          console.log("Fájl letöltése elindítva", transfer.name);
          updateTransferProgress(transfer, transfer.size || transfer.received, transfer.size || transfer.received);
          finalizeTransfer(transfer, "Fájl fogadva és letöltve.");
          return;
        }

        if (data.type === "reject") {
          finalizeTransfer(transfer, "A fogadó elutasította a küldést.");
          return;
        }

        if (data.type === "cancel") {
          transfer.isCancelled = true;
          finalizeTransfer(transfer, "A feladó megszakította az átvitelt.");
          conn.close();
        }
      });

      conn.on("close", () => {
        const transfer = getTransferByConn(conn);
        if (transfer && !transfer.completed && !transfer.isCancelled) {
          finalizeTransfer(transfer, "Megszakadt a kapcsolat.");
        }
      });

      conn.on("error", (err) => {
        console.error("P2P hiba:", err);
        const transfer = getTransferByConn(conn);
        if (transfer && !transfer.completed) {
          finalizeTransfer(transfer, "Hiba történt a P2P kapcsolatban.");
        }
      });
    }

    async function sendFileChunks(transfer) {
      if (!transfer?.conn || !transfer.file) {
        return;
      }

      const { conn, file } = transfer;
      const chunkSize = 65536;
      const bufferedThreshold = 10 * 1024 * 1024;
      let chunksSent = 0;
      let offset = 0;
      transfer.startTime = transfer.startTime || Date.now();

      while (offset < file.size) {
        if (transfer.isCancelled) {
          finalizeTransfer(transfer, "Küldés megszakítva.");
          return;
        }

        while ((conn.dataChannel?.bufferedAmount ?? 0) > bufferedThreshold) {
          await new Promise((resolve) => setTimeout(resolve, 15));
          if (transfer.isCancelled) {
            finalizeTransfer(transfer, "Küldés megszakítva.");
            return;
          }
        }
        const slice = file.slice(offset, offset + chunkSize);
        const buffer = await slice.arrayBuffer();
        conn.send({ type: "chunk", data: buffer });
        offset += buffer.byteLength;
        chunksSent += 1;

        if (chunksSent % 50 === 0 || offset >= file.size) {
          const percent = Math.min(100, Math.round((offset / file.size) * 100));
          updateTransferStatus(transfer, `Küldés: ${percent}%`);
          updateTransferProgress(transfer, offset, file.size);
        }
      }

      if (transfer.isCancelled) {
        return;
      }

      conn.send({ type: "complete" });
      updateTransferProgress(transfer, file.size, file.size);
      finalizeTransfer(transfer, "Fájl sikeresen elküldve.");
    }

    function startFileSend(receiver, file) {
      if (!peer) {
        updateReceiverStatus("A kapcsolat még nem állt fel. Próbáld újra.");
        return;
      }

      const conn = peer.connect(receiver.peerId);
      const transferId = `outgoing-${Date.now()}-${Math.random().toString(16).slice(2)}`;

      const safeName = file?.name || "ismeretlen_fajl";
      const safeSize = typeof file?.size === "number" ? file.size : 0;
      const safeType =
        file?.type && file.type.trim() !== "" ? file.type : "application/octet-stream";

      const transfer = createTransferCard({
        id: transferId,
        direction: "outgoing",
        name: safeName,
        size: safeSize,
        mimeType: safeType,
        status: `Kapcsolódás ${receiver.username} felé...`,
      });

      if (!transfer) {
        return;
      }

      transfer.conn = conn;
      transfer.file = file;
      conn.__transferId = transferId;

      const cancelBtn = createTransferButton("Mégse", "transfer-btn--cancel", () => {
        transfer.isCancelled = true;
        conn.send({ type: "cancel" });
        finalizeTransfer(transfer, "Küldés megszakítva.");
        conn.close();
      });
      setTransferActions(transfer, [cancelBtn]);

      const connectionTimeout = setTimeout(() => {
        transfer.isCancelled = true;
        finalizeTransfer(transfer, "Nem sikerült kapcsolódni 15 másodpercen belül.");
        conn.close();
      }, 15000);

      conn.on("open", () => {
        clearTimeout(connectionTimeout);
        updateTransferStatus(transfer, "Kapcsolat létrejött, metaadat küldése...");
        conn.send({ type: "meta", name: safeName, size: safeSize, mimeType: safeType });
      });

      conn.on("data", async (data) => {
        if (!data || typeof data !== "object") {
          return;
        }
        if (data.type === "accept") {
          updateTransferStatus(transfer, "Fogadó elfogadta, küldés indul...");
          transfer.startTime = Date.now();
          await sendFileChunks(transfer);
        }
        if (data.type === "reject") {
          transfer.isCancelled = true;
          finalizeTransfer(transfer, "A címzett elutasította a küldést.");
        }
        if (data.type === "cancel") {
          transfer.isCancelled = true;
          finalizeTransfer(transfer, "A címzett megszakította az átvitelt.");
        }
      });

      conn.on("close", () => {
        clearTimeout(connectionTimeout);
        if (!transfer.completed && !transfer.isCancelled) {
          finalizeTransfer(transfer, "Megszakadt a kapcsolat.");
        }
      });

      conn.on("error", (err) => {
        console.error("P2P hiba:", err);
        clearTimeout(connectionTimeout);
        if (!transfer.completed) {
          finalizeTransfer(transfer, "Hiba történt a P2P kapcsolatban.");
        }
      });
    }

    function getStoredToken() {
      return localStorage.getItem(SESSION_KEYS.token);
    }

    function isUserLoggedIn() {
      return !!getStoredToken();
    }

    function buildAuthHeaders() {
      const token = getStoredToken();
      if (!token) {
        return {};
      }
      return {
        Authorization: `Bearer ${token}`,
      };
    }

    if (savePermissionsBtn) {
      savePermissionsBtn.disabled = true;
    }

    function openLoginModal() {
      if (loginForm) {
        loginForm.reset();
      }
      loginModal.style.display = "flex";
    }

    function createOptionRow(value = "") {
      const row = document.createElement("div");
      row.className = "poll-option-row";

      const input = document.createElement("input");
      input.type = "text";
      input.className = "poll-option-input";
      input.placeholder = "Válaszlehetőség";
      input.required = true;
      input.value = value;

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "poll-option-remove";
      removeBtn.setAttribute("aria-label", "Válaszlehetőség törlése");
      removeBtn.textContent = "✕";
      removeBtn.addEventListener("click", () => {
        if (!optionsContainer) {
          return;
        }
        row.remove();
        ensureMinimumOptionRows();
        updateOptionRemoveButtons();
      });

      row.appendChild(input);
      row.appendChild(removeBtn);

      return row;
    }

    function updateOptionRemoveButtons() {
      if (!optionsContainer) {
        return;
      }

      const rows = optionsContainer.querySelectorAll(".poll-option-row");
      rows.forEach((row) => {
        const removeBtn = row.querySelector(".poll-option-remove");
        if (removeBtn) {
          removeBtn.disabled = rows.length <= POLL_MIN_OPTIONS;
        }
      });
    }

    function addOptionRow(value = "") {
      if (!optionsContainer) {
        return null;
      }

      const row = createOptionRow(value);
      optionsContainer.appendChild(row);
      updateOptionRemoveButtons();
      return row;
    }

    function ensureMinimumOptionRows() {
      if (!optionsContainer) {
        return;
      }

      const currentRows = optionsContainer.querySelectorAll(".poll-option-row").length;
      const missing = POLL_MIN_OPTIONS - currentRows;

      if (missing > 0) {
        for (let i = 0; i < missing; i += 1) {
          addOptionRow();
        }
      }

      updateOptionRemoveButtons();
    }

    function resetPollForm() {
      if (createPollForm) {
        createPollForm.reset();
      }

      if (optionsContainer) {
        optionsContainer.innerHTML = "";
      }

      ensureMinimumOptionRows();
    }

    function updatePollCreatorState(forceLoggedInState) {
      if (!pollCreator || !createPollForm) {
        return;
      }

      const loggedIn =
        typeof forceLoggedInState === "boolean" ? forceLoggedInState : isUserLoggedIn();

      if (loggedIn) {
        createPollForm.style.display = "block";
        if (pollCreatorNotice) {
          pollCreatorNotice.textContent =
            "Adj meg egy kérdést és legalább két válaszlehetőséget.";
        }
        ensureMinimumOptionRows();
      } else {
        createPollForm.style.display = "none";
        if (pollCreatorNotice) {
          pollCreatorNotice.textContent =
            "Szavazást létrehozni csak bejelentkezett felhasználók tudnak.";
        }
      }
    }

    function renderPoll(poll) {
        const card = document.createElement("div");
        card.className = "poll-card";

        const header = document.createElement("div");
        header.className = "poll-card-header";

        const title = document.createElement("h3");
        title.textContent = poll?.question || "Szavazás";
        header.appendChild(title);

        const status = document.createElement("span");
        status.className = `poll-status ${poll?.is_active ? "poll-status--active" : "poll-status--closed"}`;
        status.textContent = poll?.is_active ? "Aktív" : "Lezárt";
        header.appendChild(status);

        card.appendChild(header);

        const creatorName = poll?.creator_username || "Ismeretlen";
        const meta = document.createElement("div");
        meta.className = "poll-meta";
        let metaText = `Létrehozta: ${creatorName}`;
        if (poll?.created_at) {
            const createdAt = new Date(poll.created_at);
            if (!Number.isNaN(createdAt.valueOf())) {
                metaText += ` • ${createdAt.toLocaleString("hu-HU")}`;
            }
        }
        meta.textContent = metaText;
        card.appendChild(meta);

        if (poll?.is_active && !isUserLoggedIn()) {
            const notice = document.createElement("div");
            notice.className = "poll-hint";
            notice.textContent = "Szavazni csak bejelentkezett felhasználók tudnak.";
            card.appendChild(notice);
        }

        const optionsWrapper = document.createElement("div");
        optionsWrapper.className = "poll-options-results";

        const totalVotes = Number(poll?.totalVotes) || 0;

        if (Array.isArray(poll?.options)) {
            poll.options.forEach((option) => {
                const optionResult = document.createElement("div");
                optionResult.className = "poll-option-result";
                if (poll?.userVoteOptionId === option.id) {
                    optionResult.classList.add("poll-option-result--selected");
                }

                const headerRow = document.createElement("div");
                headerRow.className = "poll-option-header";

                const label = document.createElement("div");
                label.className = "poll-option-label";
                label.textContent = option?.option_text || "Válaszlehetőség";
                headerRow.appendChild(label);

                const count = document.createElement("div");
                count.className = "poll-option-count";
                const votes = Number(option?.vote_count) || 0;
                const percentage = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
                count.textContent = `${votes} szavazat (${percentage}%)`;
                headerRow.appendChild(count);

                if (poll?.is_active && !poll?.userVoteOptionId && isUserLoggedIn()) {
                    const voteBtn = document.createElement("button");
                    voteBtn.type = "button";
                    voteBtn.className = "poll-button poll-vote-btn";
                    voteBtn.textContent = "Szavazok";
                    voteBtn.addEventListener("click", () => handlePollVote(poll.id, option.id, voteBtn));
                    headerRow.appendChild(voteBtn);
                } else if (poll?.userVoteOptionId === option.id) {
                    const badge = document.createElement("span");
                    badge.className = "poll-badge";
                    badge.textContent = "Szavazatod";
                    headerRow.appendChild(badge);
                }

                optionResult.appendChild(headerRow);

                const bar = document.createElement("div");
                bar.className = "poll-result-bar";
                const fill = document.createElement("div");
                fill.className = "poll-result-bar-fill";
                const fillWidth = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
                fill.style.width = `${fillWidth}%`;
                bar.appendChild(fill);
                optionResult.appendChild(bar);

                const votersElement = document.createElement("div");
                votersElement.className = "poll-voters";
                if (Array.isArray(option?.voters) && option.voters.length > 0) {
                    const names = option.voters
                        .map((voter) => voter?.username || `#${voter?.id ?? "?"}`)
                        .join(", ");
                    votersElement.textContent = `Szavaztak: ${names}`;
                } else {
                    votersElement.textContent = "Még nincs szavazat.";
                }
                optionResult.appendChild(votersElement);

                optionsWrapper.appendChild(optionResult);
            });
        }

        card.appendChild(optionsWrapper);

        const totalVotesInfo = document.createElement("div");
        totalVotesInfo.className = "poll-total-votes";
        totalVotesInfo.textContent = `Összes szavazat: ${totalVotes}`;
        card.appendChild(totalVotesInfo);

        const actions = document.createElement("div");
        actions.className = "poll-actions";
        let hasAction = false;

        if (poll?.canClose) {
            const closeBtn = document.createElement("button");
            closeBtn.type = "button";
            closeBtn.className = "poll-button poll-secondary-btn";
            closeBtn.textContent = "Szavazás lezárása";
            closeBtn.addEventListener("click", () => handleClosePoll(poll.id, closeBtn));
            actions.appendChild(closeBtn);
            hasAction = true;
        }

        if (isAdminUser()) {
            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.className = "poll-button poll-close-btn";
            deleteBtn.textContent = "Törlés (Admin)";
            deleteBtn.addEventListener("click", () => handleDeletePoll(poll.id, deleteBtn));
            actions.appendChild(deleteBtn);
            hasAction = true;
        }

        if (hasAction) {
            card.appendChild(actions);
        }

        return card;
    }

    async function loadPolls() {
      if (!pollListContainer) {
        return;
      }

      pollsShouldRefresh = false;

      pollListContainer.innerHTML = "";
      const loadingElement = document.createElement("div");
      loadingElement.className = "poll-empty";
      loadingElement.textContent = "Szavazások betöltése...";
      pollListContainer.appendChild(loadingElement);

      try {
        const response = await fetch("/api/polls", { headers: buildAuthHeaders() });

        if (!response.ok) {
          throw new Error("Nem sikerült betölteni a szavazásokat.");
        }

        const polls = await response.json();
        pollListContainer.innerHTML = "";

        if (!Array.isArray(polls) || polls.length === 0) {
          const emptyElement = document.createElement("div");
          emptyElement.className = "poll-empty";
          emptyElement.textContent = "Jelenleg nincs aktív szavazás.";
          pollListContainer.appendChild(emptyElement);
          return;
        }

        polls.forEach((poll) => {
          pollListContainer.appendChild(renderPoll(poll));
        });
      } catch (error) {
        console.error("Szavazások betöltési hiba:", error);
        pollListContainer.innerHTML = "";
        const errorElement = document.createElement("div");
        errorElement.className = "poll-empty";
        errorElement.textContent = "Nem sikerült betölteni a szavazásokat.";
        pollListContainer.appendChild(errorElement);
      }
    }

    async function handlePollVote(pollId, optionId, button) {
      if (!isUserLoggedIn()) {
        alert("Szavazáshoz be kell jelentkezned.");
        if (typeof openLoginModal === "function") {
          openLoginModal();
        }
        return;
      }

      const originalText = button ? button.textContent : "";
      if (button) {
        button.disabled = true;
        button.textContent = "Küldés...";
      }

      try {
        const response = await fetch(`/api/polls/${pollId}/vote`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...buildAuthHeaders(),
          },
          body: JSON.stringify({ optionId }),
        });

        const payload = await response.json().catch(() => ({}));

        if (!response.ok) {
          const message =
            payload && payload.message
              ? payload.message
              : "Nem sikerült rögzíteni a szavazatot.";
          throw new Error(message);
        }

        await loadPolls();
      } catch (error) {
        console.error("Szavazat mentési hiba:", error);
        alert(error.message || "Nem sikerült rögzíteni a szavazatot.");
      } finally {
        if (button) {
          button.disabled = false;
          button.textContent = originalText || "Szavazok";
        }
      }
    }

    async function handleClosePoll(pollId, button) {
      if (!isUserLoggedIn()) {
        alert("A szavazás lezárásához be kell jelentkezned.");
        if (typeof openLoginModal === "function") {
          openLoginModal();
        }
        return;
      }

      if (!confirm("Biztosan lezárod a szavazást?")) {
        return;
      }

      const originalText = button ? button.textContent : "";
      if (button) {
        button.disabled = true;
        button.textContent = "Lezárás...";
      }

      try {
        const response = await fetch(`/api/polls/${pollId}/close`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...buildAuthHeaders(),
          },
        });

        const payload = await response.json().catch(() => ({}));

        if (!response.ok) {
          const message =
            payload && payload.message
              ? payload.message
              : "Nem sikerült lezárni a szavazást.";
          throw new Error(message);
        }

        await loadPolls();
      } catch (error) {
        console.error("Szavazás lezárási hiba:", error);
        alert(error.message || "Nem sikerült lezárni a szavazást.");
      } finally {
        if (button) {
          button.disabled = false;
          button.textContent = originalText || "Szavazás lezárása";
        }
      }
    }
    async function handleDeletePoll(pollId, button) {
        if (!isUserLoggedIn() || !isAdminUser()) {
            alert("Csak adminisztrátorok törölhetnek szavazásokat.");
            return;
        }

        if (!confirm("Biztosan törlöd ezt a szavazást? Ez a művelet nem vonható vissza.")) {
            return;
        }

        const originalText = button ? button.textContent : "";
        if (button) {
            button.disabled = true;
            button.textContent = "Törlés...";
        }

        try {
            const response = await fetch(`/api/polls/${pollId}`, {
                method: "DELETE",
                headers: {
                    "Content-Type": "application/json",
                    ...buildAuthHeaders(),
                },
            });

            const payload = await response.json().catch(() => ({}));

            if (!response.ok) {
                const message =
                    payload && payload.message
                        ? payload.message
                        : "Nem sikerült törölni a szavazást.";
                throw new Error(message);
            }

            await loadPolls();
        } catch (error) {
            console.error("Szavazás törlési hiba:", error);
            alert(error.message || "Nem sikerült törölni a szavazást.");
        } finally {
            if (button) {
                button.disabled = false;
                button.textContent = originalText || "Törlés (Admin)";
            }
        }
    }

    if (addOptionBtn) {
      addOptionBtn.addEventListener("click", () => {
        if (!isUserLoggedIn()) {
          alert("Szavazást létrehozni csak bejelentkezve tudsz.");
          if (typeof openLoginModal === "function") {
            openLoginModal();
          }
          return;
        }

        addOptionRow();
      });
    }

    if (createPollForm) {
      createPollForm.addEventListener("submit", async (event) => {
        event.preventDefault();

        if (!isUserLoggedIn()) {
          alert("Szavazást létrehozni csak bejelentkezve tudsz.");
          if (typeof openLoginModal === "function") {
            openLoginModal();
          }
          return;
        }

        const question = questionInput ? questionInput.value.trim() : "";
        const optionInputs = optionsContainer
          ? Array.from(optionsContainer.querySelectorAll(".poll-option-input"))
          : [];
        const optionValues = optionInputs.map((input) => input.value.trim()).filter(Boolean);

        const uniqueOptions = [];
        const seenOptions = new Set();
        optionValues.forEach((option) => {
          const key = option.toLowerCase();
          if (!seenOptions.has(key)) {
            seenOptions.add(key);
            uniqueOptions.push(option);
          }
        });

        if (!question || uniqueOptions.length < POLL_MIN_OPTIONS) {
          alert("Adj meg egy kérdést és legalább két különböző válaszlehetőséget!");
          return;
        }

        const submitButton = createPollForm.querySelector('button[type="submit"]');
        const originalText = submitButton ? submitButton.textContent : "";

        if (submitButton) {
          submitButton.disabled = true;
          submitButton.textContent = "Létrehozás...";
        }

        try {
          const response = await fetch("/api/polls", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...buildAuthHeaders(),
            },
            body: JSON.stringify({ question, options: uniqueOptions }),
          });

          const payload = await response.json().catch(() => ({}));

          if (!response.ok) {
            const message =
              payload && payload.message
                ? payload.message
                : "Nem sikerült létrehozni a szavazást.";
            throw new Error(message);
          }

          resetPollForm();
          updatePollCreatorState(true);
          await loadPolls();
        } catch (error) {
          console.error("Szavazás létrehozási hiba:", error);
          alert(error.message || "Nem sikerült létrehozni a szavazást.");
        } finally {
          if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = originalText || "Szavazás létrehozása";
          }
        }
      });
    }

    ensureMinimumOptionRows();
    updatePollCreatorState();
    markPollsForRefresh();

    if (programFileInput && programFileName) {
      programFileInput.addEventListener("change", () => {
        const file = programFileInput.files?.[0];
        programFileName.textContent = file ? file.name : "Nincs kiválasztva fájl.";
      });
    }

    if (programImageInput && programImagePreview) {
      programImageInput.addEventListener("change", () => {
        const file = programImageInput.files?.[0];

        if (programImageCropper) {
          programImageCropper.destroy();
          programImageCropper = null;
        }

        if (programImageObjectUrl) {
          URL.revokeObjectURL(programImageObjectUrl);
          programImageObjectUrl = null;
        }

        if (!file) {
          programImagePreview.removeAttribute("src");
          return;
        }

        programImageObjectUrl = URL.createObjectURL(file);
        programImagePreview.src = programImageObjectUrl;
        programImageCropper = new Cropper(programImagePreview, {
          aspectRatio: 1,
          viewMode: 1,
          dragMode: "move",
          background: false,
          autoCropArea: 1,
          responsive: true,
        });
      });
    }

      function openProgramUploadModal() {
        if (!isAdminUser()) {
          alert("Csak adminok tölthetnek fel új programokat.");
          return;
        }

        setProgramUploadMode("create");
        resetProgramUploadModal();
        if (programUploadModal) {
          programUploadModal.style.display = "flex";
        }
      }

      function openProgramEditModal(program) {
        if (!isAdminUser()) {
          alert("Csak admin szerkeszthet programot.");
          return;
        }

        if (!program || !program.id) {
          return;
        }

        resetProgramUploadModal();
        setProgramUploadMode("edit", program);

        if (programNameInput) {
          programNameInput.value = program.name || "";
        }

        if (programDescriptionInput) {
          programDescriptionInput.value = program.description || "";
        }

        if (programFileName) {
          programFileName.textContent = program.original_filename || "Nincs kiválasztva fájl.";
        }

        if (programImagePreview) {
          if (program.image_filename) {
            programImagePreview.src = `/uploads/programs/images/${program.image_filename}`;
          } else {
            programImagePreview.removeAttribute("src");
          }
        }

        if (programUploadModal) {
          programUploadModal.style.display = "flex";
        }
      }

    if (addProgramBtn) {
      addProgramBtn.addEventListener("click", openProgramUploadModal);
    }

    if (closeProgramUploadModalBtn) {
      closeProgramUploadModalBtn.addEventListener("click", () => {
        closeProgramUploadModal();
      });
    }

    if (cancelProgramUploadBtn) {
      cancelProgramUploadBtn.addEventListener("click", () => {
        closeProgramUploadModal();
      });
    }

    if (programUploadModal) {
      programUploadModal.addEventListener("click", (event) => {
        if (event.target === programUploadModal) {
          closeProgramUploadModal();
        }
      });
    }

    if (programUploadForm) {
      programUploadForm.addEventListener("submit", async (event) => {
        event.preventDefault();

        if (!isAdminUser()) {
          alert("Csak adminok menthetnek programokat.");
          return;
        }

        const isEditMode = Boolean(editingProgram && editingProgram.id);
        const name = programNameInput?.value.trim();
        const description = programDescriptionInput?.value.trim();
        const file = programFileInput?.files?.[0];

        if (!name || !description) {
          alert("A név és a leírás megadása kötelező.");
          return;
        }

        if (!file && !isEditMode) {
          alert("Válassz ki egy feltöltendő program fájlt.");
          return;
        }

        let imageBlob = null;
        try {
          if (programImageCropper) {
            imageBlob = await new Promise((resolve, reject) => {
              const canvas = programImageCropper.getCroppedCanvas({
                width: 1200,
                height: 1200,
              });
              if (!canvas) {
                reject(new Error("Nem sikerült a kép vágása."));
                return;
              }
              canvas.toBlob((blob) => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error("Nem sikerült a kép vágása."));
                }
              }, "image/png");
            });
          } else if (programImageInput?.files?.[0]) {
            imageBlob = programImageInput.files[0];
          }
        } catch (error) {
          console.error("Kép feldolgozási hiba:", error);
          alert(error.message || "Nem sikerült feldolgozni a képet.");
          return;
        }

        if (!imageBlob && !isEditMode) {
          alert("Adj meg egy borítóképet a programhoz.");
          return;
        }

        const formData = new FormData();
        formData.append("name", name);
        formData.append("description", description);
        if (imageBlob) {
          formData.append("image", imageBlob, "program-image.png");
        }
        if (file) {
          formData.append("file", file);
        }

        const endpoint = isEditMode ? `/api/programs/${editingProgram.id}` : "/api/programs";
        const method = isEditMode ? "PUT" : "POST";

        const originalText = submitProgramUploadBtn?.textContent;
        if (submitProgramUploadBtn) {
          submitProgramUploadBtn.disabled = true;
          submitProgramUploadBtn.textContent = isEditMode ? "Frissítés..." : "Mentés...";
        }

        try {
          const response = await fetch(endpoint, {
            method,
            headers: buildAuthHeaders(),
            body: formData,
          });

          const payload = await response.json().catch(() => ({}));

          if (!response.ok) {
            const message = payload?.message || (isEditMode ? "Nem sikerült frissíteni a programot." : "Nem sikerült menteni a programot.");
            throw new Error(message);
          }

          closeProgramUploadModal();
          await loadPrograms();
        } catch (error) {
          console.error("Program feltöltési hiba:", error);
          alert(error.message || "Nem sikerült feltölteni a programot.");
        } finally {
          if (submitProgramUploadBtn) {
            submitProgramUploadBtn.disabled = false;
            submitProgramUploadBtn.textContent = originalText || "Mentés";
          }
        }
      });
    }

      function updateAdminNavVisibility() {
        const isAdmin = isAdminUser();

        if (adminNavBtn) {
          adminNavBtn.style.display = isAdmin ? "inline-block" : "none";
        }

        updateProgramAdminControls();

        if (!isAdmin) {
          const activeSection = document.querySelector("main section.active");
          if (
            activeSection &&
          typeof ADMIN_ONLY_SECTIONS !== "undefined" &&
          ADMIN_ONLY_SECTIONS.has(activeSection.id)
        ) {
          showSection("home");
        }
        if (userListContainer) {
          userListContainer.innerHTML = "";
        }
        if (savePermissionsBtn) {
          savePermissionsBtn.disabled = true;
        }
      }
    }

    function updateFileTransferNavVisibility() {
      const hasAccess = hasFileTransferPermission();

      if (fileTransferNavBtn) {
        fileTransferNavBtn.style.display = hasAccess ? "inline-block" : "none";
      }

      if (!hasAccess) {
        const activeSection = document.querySelector("main section.active");
        if (activeSection && activeSection.id === "fajlkuldes") {
          showSection("home");
        }
      }
    }

    function updateUIForLoggedIn(username, profilePictureFilename) {
      if (userGreeting) {
        userGreeting.textContent = username;
      }

      updateSelfLabelText(username);

      const avatarUrl = profilePictureFilename ? `/uploads/avatars/${profilePictureFilename}` : 'program_icons/default-avatar.png';
      const userAvatar = document.getElementById('userAvatar');
      if (userAvatar) {
        userAvatar.src = avatarUrl;
      }
      if (selfAvatar) {
        selfAvatar.src = avatarUrl;
      }
      const profileAvatarPreview = document.getElementById('profileAvatarPreview');
      if (profileAvatarPreview && !profileAvatarPreview.dataset.override) {
        profileAvatarPreview.src = avatarUrl;
      }

      const newUsernameInput = document.getElementById('newUsername');
      if (newUsernameInput && document.activeElement !== newUsernameInput) {
        newUsernameInput.value = username || '';
      }

      if (authLoggedOut) {
        authLoggedOut.style.display = "none";
      }
      if (authLoggedIn) {
        authLoggedIn.style.display = "flex";
      }

      updateAdminNavVisibility();
      updateProgramAdminControls();
      updateFileTransferNavVisibility();
      updateClipAccessUI();
      updatePollCreatorState(true);
      markPollsForRefresh();
      loadPrograms();

      if (hasFileTransferPermission()) {
        initializeRealtimeFeatures();
        updateReceiverStatus("Kapcsolódj a fogadó módhoz a kapcsolóval.");
      } else {
        teardownRealtimeFeatures();
        updateReceiverStatus("Nincs jogosultságod a fájlküldéshez.");
      }
    }

    function updateUIForLoggedOut() {
      // Clear session data from localStorage
      localStorage.removeItem(SESSION_KEYS.token);
      localStorage.removeItem(SESSION_KEYS.username);
      localStorage.removeItem(SESSION_KEYS.isAdmin);
      localStorage.removeItem(SESSION_KEYS.canTransfer);
      localStorage.removeItem(SESSION_KEYS.canViewClips);
      localStorage.removeItem(SESSION_KEYS.profilePictureFilename);

      if (authLoggedOut) {
        authLoggedOut.style.display = "flex";
      }
      if (authLoggedIn) {
        authLoggedIn.style.display = "none";
      }
      if (userGreeting) {
        userGreeting.textContent = "";
      }
      updateSelfLabelText();
      const profileAvatarPreview = document.getElementById('profileAvatarPreview');
      if (profileAvatarPreview) {
        delete profileAvatarPreview.dataset.override;
        profileAvatarPreview.src = 'program_icons/default-avatar.png';
      }
      const userAvatar = document.getElementById('userAvatar');
      if (userAvatar) {
        userAvatar.src = 'program_icons/default-avatar.png';
      }
      if (selfAvatar) {
        selfAvatar.src = 'program_icons/default-avatar.png';
      }
      const newUsernameInput = document.getElementById('newUsername');
      if (newUsernameInput) {
        newUsernameInput.value = '';
      }
      updateAdminNavVisibility();
      updateProgramAdminControls();
      updateFileTransferNavVisibility();
      updateClipAccessUI();
      updatePollCreatorState(false);
      markPollsForRefresh();
      loadPrograms();
      teardownRealtimeFeatures();
      updateReceiverStatus("Csatlakozz bejelentkezés után a fogadó módhoz.");
    }

    if (loginBtn) {
      loginBtn.addEventListener("click", openLoginModal);
    }

    if (registerBtn) {
      registerBtn.addEventListener("click", () => {
        window.location.href = "register.html";
      });
    }

    function renderUserList(users) {
      if (!userListContainer) {
        return;
      }

      userListContainer.innerHTML = "";

      if (!Array.isArray(users) || users.length === 0) {
        userListContainer.textContent = "Nincs megjeleníthető felhasználó.";
        if (savePermissionsBtn) {
          savePermissionsBtn.disabled = true;
        }
        return;
      }

      const table = document.createElement("table");
      table.className = "user-table";

        const thead = document.createElement("thead");
        thead.innerHTML = `
          <tr>
            <th>Felhasználónév</th>
            <th>Feltöltési jogosultság</th>
            <th>P2P Jog</th>
          <th>Klip nézési jog</th>
            <th>Max fájlméret (MB)</th>
            <th>Videó limit</th>
            <th>Feltöltött videók</th>
          </tr>
        `;
      table.appendChild(thead);

      const tbody = document.createElement("tbody");

      users.forEach((user) => {
        const row = document.createElement("tr");
        row.dataset.userId = user.id;

        const usernameCell = document.createElement("td");
        usernameCell.textContent = user.username;
        row.appendChild(usernameCell);

        const permissionCell = document.createElement("td");
        const label = document.createElement("label");
        label.className = "permission-toggle";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.name = "canUpload";
        checkbox.checked = Number(user.can_upload) === 1;
        label.appendChild(checkbox);
        label.append(" Feltölthet");
        permissionCell.appendChild(label);
        row.appendChild(permissionCell);

        const transferCell = document.createElement("td");
        const transferLabel = document.createElement("label");
        transferLabel.className = "permission-toggle";
        const transferCheckbox = document.createElement("input");
        transferCheckbox.type = "checkbox";
        transferCheckbox.name = "canTransfer";
        transferCheckbox.checked = Number(user.can_transfer) === 1;
        transferLabel.appendChild(transferCheckbox);
        transferLabel.append(" P2P");
        transferCell.appendChild(transferLabel);
        row.appendChild(transferCell);

        const viewClipsCell = document.createElement("td");
        const viewClipsLabel = document.createElement("label");
        viewClipsLabel.className = "permission-toggle";
        const viewClipsCheckbox = document.createElement("input");
        viewClipsCheckbox.type = "checkbox";
        viewClipsCheckbox.name = "canViewClips";
        viewClipsCheckbox.checked = Number(user.can_view_clips) === 1;
        viewClipsLabel.appendChild(viewClipsCheckbox);
        viewClipsLabel.append(" Klipek");
        viewClipsCell.appendChild(viewClipsLabel);
        row.appendChild(viewClipsCell);

        const maxFileSizeCell = document.createElement("td");
        const maxFileInput = document.createElement("input");
        maxFileInput.type = "number";
        maxFileInput.min = "1";
        maxFileInput.required = true;
        maxFileInput.name = "maxFileSizeMb";
        maxFileInput.value = Number.parseInt(user.max_file_size_mb, 10) || "";
        maxFileSizeCell.appendChild(maxFileInput);
        row.appendChild(maxFileSizeCell);

        const maxVideosCell = document.createElement("td");
        const maxVideosInput = document.createElement("input");
        maxVideosInput.type = "number";
        maxVideosInput.min = "1";
        maxVideosInput.required = true;
        maxVideosInput.name = "maxVideos";
        maxVideosInput.value = Number.parseInt(user.max_videos, 10) || "";
        maxVideosCell.appendChild(maxVideosInput);
        row.appendChild(maxVideosCell);

        const uploadsCell = document.createElement("td");
        uploadsCell.textContent = Number.parseInt(user.upload_count, 10) || 0;
        row.appendChild(uploadsCell);

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      userListContainer.appendChild(table);

      if (savePermissionsBtn) {
        savePermissionsBtn.disabled = false;
      }
    }

    async function loadAdminPanel() {
      if (!isUserLoggedIn()) {
        alert("Nincs érvényes hitelesítés.");
        return;
      }

      try {
        const response = await fetch("/api/users", {
          method: "GET",
          headers: buildAuthHeaders(),
        });

        const data = await response.json().catch(() => null);

        if (!response.ok) {
          const message = data && data.message ? data.message : "Nem sikerült betölteni a felhasználókat.";
          throw new Error(message);
        }

        renderUserList(Array.isArray(data) ? data : []);
      } catch (error) {
        console.error("Admin panel betöltési hiba:", error);
        alert(error.message || "Nem sikerült betölteni az admin panel adatait.");
        if (savePermissionsBtn) {
          savePermissionsBtn.disabled = true;
        }
      }
    }

    async function fetchAdminClips(variant) {
      const params = new URLSearchParams();
      if (variant) {
        params.set("type", variant);
      }

      const url = params.toString() ? `/api/admin/clips?${params.toString()}` : "/api/admin/clips";
      const response = await fetch(url, { headers: buildAuthHeaders() });
      const data = await response.json().catch(() => null);

      if (!response.ok) {
        const message = data && data.message ? data.message : "Nem sikerült lekérdezni a klipeket.";
        throw new Error(message);
      }

      const items = Array.isArray(data?.items) ? data.items : Array.isArray(data) ? data : [];
      const total = Number.isFinite(data?.total) ? data.total : items.length;

      return { items, total };
    }

    async function fetchProcessingStatus() {
      const response = await fetch("/api/admin/processing-status", { headers: buildAuthHeaders() });
      const data = await response.json().catch(() => null);

      if (!response.ok) {
        const message = data && data.message ? data.message : "Nem sikerült lekérdezni a feldolgozási állapotot.";
        throw new Error(message);
      }

      return {
        isProcessing: Boolean(data?.isProcessing),
        currentTask: data?.currentTask || null,
        pending: Array.isArray(data?.pending) ? data.pending : [],
      };
    }

    function createClipListWindowLayout(clipWindow) {
      const doc = clipWindow.document;

      doc.title = "Klipek listája";
      doc.body.innerHTML = `
        <style>
          body {
            font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f3f4f6;
            color: #111827;
            margin: 0;
            padding: 20px;
          }

          .clip-window {
            max-width: 1200px;
            margin: 0 auto;
            font-size: 14px;
          }

          .clip-window h1 {
            margin: 0 0 6px;
            font-size: 20px;
          }

          .clip-window__subtitle {
            margin: 0 0 16px;
            color: #4b5563;
          }

          .clip-window__controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
          }

          .clip-window__select {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            min-width: 220px;
            font-size: 14px;
          }

          .clip-window__count {
            color: #4b5563;
            font-size: 13px;
          }

          .clip-window__status {
            margin-bottom: 10px;
            color: #374151;
          }

          .clip-window__table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
          }

          .clip-window__table thead {
            background: #e5e7eb;
          }

          .clip-window__table th,
          .clip-window__table td {
            padding: 8px 10px;
            border-bottom: 1px solid #e5e7eb;
            text-align: left;
            vertical-align: top;
          }

          .clip-window__table th {
            font-weight: 600;
          }

          .clip-window__table tr:last-child td {
            border-bottom: none;
          }

          .clip-window__delete {
            background: #dc2626;
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s ease;
          }

          .clip-window__delete:disabled {
            opacity: 0.6;
            cursor: not-allowed;
          }

          .clip-window__delete:not(:disabled):hover {
            background: #b91c1c;
          }
        </style>
        <div class="clip-window">
          <h1>Feltöltött klipek</h1>
          <p class="clip-window__subtitle">Egyszerű, áttekinthető lista a klipjeidről.</p>
          <div class="clip-window__controls">
            <label for="clipWindowVariant">Megjelenített fájlok</label>
            <select id="clipWindowVariant" class="clip-window__select">
              <option value="original">Eredeti videók</option>
              <option value="720p">720p videók</option>
              <option value="other">Egyéb fájlok</option>
            </select>
            <span id="clipWindowCount" class="clip-window__count"></span>
          </div>
          <div id="clipWindowStatus" class="clip-window__status">Klipek betöltése folyamatban...</div>
          <div id="clipWindowTable"></div>
        </div>
      `;

      return {
        doc,
        statusEl: doc.getElementById("clipWindowStatus"),
        tableContainer: doc.getElementById("clipWindowTable"),
        variantSelect: doc.getElementById("clipWindowVariant"),
        countEl: doc.getElementById("clipWindowCount"),
      };
    }

    async function handleClipDeleteFromWindow(clipId, rowElement, button, clipName, statusEl) {
      if (!Number.isFinite(clipId)) {
        return;
      }

      const confirmed = window.confirm(`Biztosan törlöd a(z) "${clipName || "klip"}" elemet? A törlés végleges.`);
      if (!confirmed) {
        return;
      }

      if (button) {
        button.disabled = true;
      }

      try {
        const response = await fetch(`/api/videos/${clipId}`, {
          method: "DELETE",
          headers: buildAuthHeaders(),
        });

        const data = await response.json().catch(() => null);
        if (!response.ok) {
          const message = data && data.message ? data.message : "Nem sikerült törölni a klipet.";
          throw new Error(message);
        }

        if (rowElement && rowElement.parentElement) {
          rowElement.parentElement.removeChild(rowElement);
        }

        const remainingRows = rowElement?.parentElement?.children?.length || 0;
        if (remainingRows === 0 && statusEl) {
          statusEl.textContent = "Nincs feltöltött klip.";
        }
      } catch (error) {
        console.error("Klip törlési hiba:", error);
        alert(error.message || "Nem sikerült törölni a klipet.");
      } finally {
        if (button) {
          button.disabled = false;
        }
      }
    }

    function renderClipTableInWindow(doc, tableContainer, statusEl, clips, countEl) {
      if (!tableContainer) {
        return;
      }

      tableContainer.innerHTML = "";

      if (!Array.isArray(clips) || clips.length === 0) {
        if (statusEl) {
          statusEl.textContent = "Nincs feltöltött klip.";
        }
        if (countEl) {
          countEl.textContent = "";
        }
        return;
      }

      if (statusEl) {
        statusEl.textContent = "";
      }

      if (countEl) {
        countEl.textContent = `Megjelenített elemek: ${clips.length}`;
      }

      const table = doc.createElement("table");
      table.className = "clip-window__table";

      const thead = doc.createElement("thead");
      const headerRow = doc.createElement("tr");
      ["Szép cím", "Adatbázis cím", "Fájlméret", "Feltöltési idő", "Egyéb", "Művelet"].forEach((text) => {
        const th = doc.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = doc.createElement("tbody");

      clips.forEach((clip) => {
        const row = doc.createElement("tr");

        const prettyTitle = doc.createElement("td");
        prettyTitle.textContent = clip.original_name || "Ismeretlen név";
        row.appendChild(prettyTitle);

        const dbTitle = doc.createElement("td");
        dbTitle.textContent = clip.filename || "-";
        row.appendChild(dbTitle);

        const sizeCell = doc.createElement("td");
        sizeCell.textContent = formatFileSize(Number(clip.sizeBytes));
        row.appendChild(sizeCell);

        const uploadedCell = doc.createElement("td");
        uploadedCell.textContent = formatDateTime(clip.uploaded_at);
        row.appendChild(uploadedCell);

        const extraCell = doc.createElement("td");
        const extraParts = [];
        if (clip.uploader) {
          extraParts.push(`Feltöltő: ${clip.uploader}`);
        }
        if (clip.category === "720p") {
          extraParts.push("Verzió: 720p");
        } else if (clip.category === "other") {
          extraParts.push("Típus: Egyéb fájl");
        } else {
          extraParts.push("Verzió: Eredeti");
        }
        extraCell.textContent = extraParts.length ? extraParts.join(" • ") : "-";
        row.appendChild(extraCell);

        const actionCell = doc.createElement("td");
        const deleteBtn = doc.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.textContent = "Törlés";
        deleteBtn.className = "clip-window__delete";
        deleteBtn.addEventListener("click", () => {
          handleClipDeleteFromWindow(clip.id, row, deleteBtn, clip.original_name, statusEl);
        });
        actionCell.appendChild(deleteBtn);
        row.appendChild(actionCell);

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      tableContainer.appendChild(table);
    }

    async function openClipListWindow() {
      if (!isUserLoggedIn()) {
        alert("Nincs érvényes hitelesítés.");
        return;
      }

      const clipWindow = window.open("", "_blank");
      if (!clipWindow || clipWindow.closed) {
        alert("Nem sikerült megnyitni az új ablakot.");
        return;
      }

      const { doc, statusEl, tableContainer, variantSelect, countEl } = createClipListWindowLayout(clipWindow);

      const selectedVariant = "original";
      if (variantSelect) {
        variantSelect.value = selectedVariant;
      }

      const loadVariant = async (variant) => {
        if (statusEl) {
          statusEl.textContent = "Klipek betöltése folyamatban...";
        }
        if (countEl) {
          countEl.textContent = "";
        }
        if (tableContainer) {
          tableContainer.innerHTML = "";
        }

        try {
          const { items } = await fetchAdminClips(variant);
          renderClipTableInWindow(doc, tableContainer, statusEl, items, countEl);
        } catch (error) {
          console.error("Klip lista betöltési hiba:", error);
          if (statusEl) {
            statusEl.textContent = error.message || "Nem sikerült betölteni a klipeket.";
          }
        }
      };

      if (variantSelect) {
        variantSelect.addEventListener("change", (event) => {
          const value = event.target?.value || "original";
          loadVariant(value);
        });
      }

      await loadVariant(selectedVariant);
    }

    function formatHungarianDate(value) {
      const parsedDate = value ? new Date(value) : null;
      if (!parsedDate || Number.isNaN(parsedDate.getTime())) {
        return "Ismeretlen időpont";
      }

      return parsedDate.toLocaleString("hu-HU", {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
      });
    }

    function createProcessingStatusWindowLayout(processWindow) {
      const doc = processWindow.document;

      doc.title = "Feldolgozási állapot";
      doc.body.innerHTML = `
        <style>
          body {
            font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f3f4f6;
            color: #111827;
            margin: 0;
            padding: 20px;
          }

          .process-window {
            max-width: 960px;
            margin: 0 auto;
          }

          .process-window h1 {
            margin-bottom: 4px;
          }

          .process-window__subtitle {
            color: #4b5563;
            margin-top: 0;
          }

          .process-window__status {
            background: #e5e7eb;
            color: #1f2937;
            padding: 10px 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-weight: 600;
          }

          .process-window__card {
            background: #fff;
            border-radius: 10px;
            padding: 14px 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            margin-bottom: 16px;
          }

          .process-window__card h3 {
            margin: 0 0 6px 0;
            font-size: 16px;
          }

          .process-window__meta {
            color: #4b5563;
            margin: 2px 0;
            font-size: 13px;
          }

          .process-window__queue-header {
            display: flex;
            align-items: center;
            gap: 10px;
          }

          .process-window__badge {
            background: #2563eb;
            color: #fff;
            padding: 4px 10px;
            border-radius: 999px;
            font-weight: 600;
            font-size: 12px;
          }

          .process-window__list {
            list-style: none;
            padding: 0;
            margin: 12px 0 20px 0;
          }

          .process-window__list li + li {
            margin-top: 10px;
          }

          .process-window__empty {
            color: #6b7280;
            font-style: italic;
          }

          .process-window__refresh {
            background: #111827;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
          }

          .process-window__refresh:hover {
            background: #1f2937;
          }
        </style>
        <div class="process-window">
          <h1>Feldolgozási állapot</h1>
          <p class="process-window__subtitle">Aktuális feladat és várakozó fájlok áttekintése.</p>
          <div id="processStatusText" class="process-window__status">Állapot betöltése...</div>
          <div id="processCurrentTask"></div>
          <div class="process-window__queue-header">
            <h2>Várakozó fájlok</h2>
            <span id="processQueueCount" class="process-window__badge"></span>
          </div>
          <ul id="processQueueList" class="process-window__list"></ul>
          <button id="processRefreshBtn" type="button" class="process-window__refresh">Frissítés</button>
        </div>
      `;

      return {
        doc,
        statusEl: doc.getElementById("processStatusText"),
        currentTaskEl: doc.getElementById("processCurrentTask"),
        queueListEl: doc.getElementById("processQueueList"),
        queueCountEl: doc.getElementById("processQueueCount"),
        refreshBtn: doc.getElementById("processRefreshBtn"),
      };
    }

    function renderProcessingCard(doc, container, item, titlePrefix) {
      if (!container) {
        return;
      }

      container.innerHTML = "";

      if (!item) {
        const empty = doc.createElement("p");
        empty.className = "process-window__empty";
        empty.textContent = "Jelenleg nincs aktív feldolgozási feladat.";
        container.appendChild(empty);
        return;
      }

      const card = doc.createElement("div");
      card.className = "process-window__card";

      const title = doc.createElement("h3");
      title.textContent = `${titlePrefix || "Fájl"}: ${item.original_name || item.filename || "Ismeretlen"}`;
      card.appendChild(title);

      const fileMeta = doc.createElement("p");
      fileMeta.className = "process-window__meta";
      fileMeta.textContent = `Elérési út: ${item.filename || "-"}`;
      card.appendChild(fileMeta);

      const timeMeta = doc.createElement("p");
      timeMeta.className = "process-window__meta";
      timeMeta.textContent = `Feltöltve: ${formatHungarianDate(item.uploaded_at)}`;
      card.appendChild(timeMeta);

      const statusMeta = doc.createElement("p");
      statusMeta.className = "process-window__meta";
      statusMeta.textContent = `Státusz: ${item.processing_status || "ismeretlen"}`;
      card.appendChild(statusMeta);

      container.appendChild(card);
    }

    async function openProcessingStatusWindow() {
      if (!isUserLoggedIn()) {
        alert("Nincs érvényes hitelesítés.");
        return;
      }

      const processWindow = window.open("", "_blank");
      if (!processWindow || processWindow.closed) {
        alert("Nem sikerült megnyitni az új ablakot.");
        return;
      }

      const { doc, statusEl, currentTaskEl, queueListEl, queueCountEl, refreshBtn } = createProcessingStatusWindowLayout(processWindow);

      const renderQueue = (items) => {
        if (!queueListEl) {
          return;
        }

        queueListEl.innerHTML = "";

        if (!items || !items.length) {
          const empty = doc.createElement("li");
          empty.className = "process-window__empty";
          empty.textContent = "Nincs várakozó fájl a sorban.";
          queueListEl.appendChild(empty);
          return;
        }

        items.forEach((item, index) => {
          const li = doc.createElement("li");
          renderProcessingCard(doc, li, item, `#${index + 1}`);
          queueListEl.appendChild(li);
        });
      };

      const loadStatus = async () => {
        if (statusEl) {
          statusEl.textContent = "Állapot betöltése folyamatban...";
        }
        renderProcessingCard(doc, currentTaskEl, null);
        renderQueue([]);
        if (queueCountEl) {
          queueCountEl.textContent = "";
        }

        try {
          const data = await fetchProcessingStatus();

          if (statusEl) {
            statusEl.textContent = data.isProcessing
              ? "A szerver jelenleg feldolgoz egy fájlt."
              : "Jelenleg nincs aktív feldolgozási feladat.";
          }

          renderProcessingCard(doc, currentTaskEl, data.currentTask, "Aktív");
          renderQueue(data.pending);

          if (queueCountEl) {
            queueCountEl.textContent = `${data.pending.length} elem`; 
          }
        } catch (error) {
          console.error("Feldolgozási állapot betöltési hiba:", error);
          if (statusEl) {
            statusEl.textContent = error.message || "Nem sikerült lekérdezni az állapotot.";
          }
        }
      };

      if (refreshBtn) {
        refreshBtn.addEventListener("click", loadStatus);
      }

      await loadStatus();
    }

    if (savePermissionsBtn) {
      const originalButtonText = savePermissionsBtn.textContent;

      savePermissionsBtn.addEventListener("click", async () => {
        if (!isUserLoggedIn()) {
          alert("Nincs érvényes hitelesítés.");
          return;
        }

        if (!userListContainer) {
          alert("Nem található a felhasználói lista.");
          return;
        }

        const tableBody = userListContainer.querySelector("tbody");
        if (!tableBody) {
          alert("Nincs mentésre váró adat.");
          return;
        }

        const rows = Array.from(tableBody.querySelectorAll("tr"));
        const invalidEntries = [];
        const permissionsToUpdate = rows
          .map((row) => {
            const uploadCheckbox = row.querySelector('input[name="canUpload"]');
            const transferCheckbox = row.querySelector('input[name="canTransfer"]');
            const viewClipsCheckbox = row.querySelector('input[name="canViewClips"]');
            const maxFileSizeInput = row.querySelector('input[name="maxFileSizeMb"]');
            const maxVideosInput = row.querySelector('input[name="maxVideos"]');
            const userIdAttr = row.dataset.userId;

            if (!uploadCheckbox || !transferCheckbox || !viewClipsCheckbox || !maxFileSizeInput || !maxVideosInput || !userIdAttr) {
              return null;
            }

            const userId = Number.parseInt(userIdAttr, 10);
            if (Number.isNaN(userId)) {
              return null;
            }

            const maxFileSizeValue = Number.parseInt(maxFileSizeInput.value, 10);
            const maxVideosValue = Number.parseInt(maxVideosInput.value, 10);

            if (!Number.isFinite(maxFileSizeValue) || maxFileSizeValue <= 0 || !Number.isFinite(maxVideosValue) || maxVideosValue <= 0) {
              const usernameCell = row.querySelector("td");
              const identifier = usernameCell ? usernameCell.textContent.trim() : `ID ${userId}`;
              invalidEntries.push(identifier);
              return null;
            }

            return {
              userId,
              canUpload: uploadCheckbox.checked,
              canTransfer: transferCheckbox.checked,
              canViewClips: viewClipsCheckbox.checked,
              maxFileSizeMb: maxFileSizeValue,
              maxVideos: maxVideosValue,
            };
          })
          .filter(Boolean);

        if (invalidEntries.length > 0) {
          alert(`Adj meg érvényes, pozitív limiteket a következő felhasználóknál: ${invalidEntries.join(", ")}.`);
          return;
        }

        if (permissionsToUpdate.length === 0) {
          alert("Nincs mentésre váró adat.");
          return;
        }

        savePermissionsBtn.disabled = true;
        savePermissionsBtn.textContent = "Mentés folyamatban...";

        try {
          const response = await fetch("/api/users/permissions/batch-update", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...buildAuthHeaders(),
            },
            body: JSON.stringify(permissionsToUpdate),
          });

          const result = await response.json().catch(() => null);

          if (!response.ok) {
            const message = result && result.message ? result.message : "Nem sikerült menteni a jogosultságokat.";
            throw new Error(message);
          }

          alert((result && result.message) || "Jogosultságok sikeresen frissítve.");
          await loadAdminPanel();
        } catch (error) {
          console.error("Jogosultság mentési hiba:", error);
          alert(error.message || "Nem sikerült menteni a jogosultságokat.");
        } finally {
          savePermissionsBtn.disabled = false;
          savePermissionsBtn.textContent = originalButtonText;
        }
      });
    }

    if (closeLogin) {
      closeLogin.addEventListener("click", () => {
        loginModal.style.display = "none";
      });
    }

    if (adminNavBtn) {
      adminNavBtn.addEventListener("click", loadAdminPanel);
    }

    const VIDEO_MANAGEMENT_PATH = "/video-kezeles-felulet.html";

    if (loadClipsBtn) {
      loadClipsBtn.addEventListener("click", () => {
        window.open(VIDEO_MANAGEMENT_PATH, "_blank");
      });
    }

    if (processingStatusBtn) {
      processingStatusBtn.addEventListener("click", () => {
        window.open(VIDEO_MANAGEMENT_PATH, "_blank");
      });
    }

    const feedbackModal = document.getElementById("feedbackModal");
    const feedbackModalTitle = document.getElementById("feedbackModalTitle");
    const feedbackModalMessage = document.getElementById("feedbackModalMessage");
    const feedbackModalClose = document.getElementById("feedbackModalClose");
    const feedbackModalOk = document.getElementById("feedbackModalOk");
    let feedbackModalOnClose = null;

    const hideFeedbackModal = () => {
      feedbackModal.style.display = "none";
      feedbackModalTitle.textContent = "";
      feedbackModalMessage.textContent = "";
      const onClose = feedbackModalOnClose;
      feedbackModalOnClose = null;
      if (typeof onClose === "function") {
        onClose();
      }
    };

    const showFeedbackModal = ({ title, message, onClose }) => {
      feedbackModalTitle.textContent = title;
      feedbackModalMessage.textContent = message;
      feedbackModalOnClose = typeof onClose === "function" ? onClose : null;
      feedbackModal.style.display = "flex";
      feedbackModalOk.focus();
    };

    feedbackModalClose.addEventListener("click", hideFeedbackModal);
    feedbackModalOk.addEventListener("click", hideFeedbackModal);
    feedbackModal.addEventListener("click", (event) => {
      if (event.target === feedbackModal) {
        hideFeedbackModal();
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && feedbackModal.style.display === "flex") {
        hideFeedbackModal();
      }
    });

    if (logoutBtn) {
      logoutBtn.addEventListener("click", () => {
        updateUIForLoggedOut();
        showFeedbackModal({
          title: "Kijelentkezés",
          message: "Sikeresen kijelentkeztél.",
        });
      });
    }

    loginForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const username = document.getElementById("loginUser").value;
      const password = document.getElementById("loginPass").value;

      try {
        const res = await fetch("/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username, password }),
        });

        const data = await res.json();

        if (res.ok) {
          const canTransfer = data.canTransfer === true || data.canTransfer === 1;
          const canViewClips = data.canViewClips === true || data.canViewClips === 1;
          localStorage.setItem(SESSION_KEYS.token, data.token);
          localStorage.setItem(SESSION_KEYS.username, data.username);
          localStorage.setItem(SESSION_KEYS.isAdmin, data.isAdmin);
          localStorage.setItem(SESSION_KEYS.canTransfer, canTransfer ? "true" : "false");
          localStorage.setItem(SESSION_KEYS.canViewClips, canViewClips ? "true" : "false");
          if (data.profile_picture_filename) {
            localStorage.setItem(SESSION_KEYS.profilePictureFilename, data.profile_picture_filename);
          } else {
            localStorage.removeItem(SESSION_KEYS.profilePictureFilename);
          }

          applyQualityPreference(data.preferred_quality || DEFAULT_VIDEO_QUALITY);

          updateUIForLoggedIn(data.username, data.profile_picture_filename);
          loginModal.style.display = "none";
          showFeedbackModal({
            title: "Sikeres bejelentkezés",
            message: data.message || "Sikeres bejelentkezés.",
          });
        } else {
          alert(data.message || "Hibás felhasználónév vagy jelszó.");
        }
      } catch (error) {
        console.error("Bejelentkezési hiba:", error);
        alert("Hiba történt a bejelentkezés során. Próbáld meg később.");
      }
    });

    window.addEventListener("load", () => {
        ensureSessionOnLoad();
        loadPrograms();
    });

    const userProfileLink = document.getElementById('userProfileLink');
    if (userProfileLink) {
        userProfileLink.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('profile');
        });
    }

    async function ensureSessionOnLoad() {
        const token = getStoredToken();
        if (!token) {
            updateUIForLoggedOut();
            return;
        }

        try {
            const response = await fetch('/api/profile', {
                method: 'GET',
                headers: buildAuthHeaders(),
            });

            if (response.status === 401 || response.status === 403) {
                // Token is invalid or expired
                updateUIForLoggedOut();
                return;
            }

            if (!response.ok) {
                // Other server errors, maybe retry later or show a generic error
                // For now, we'll just log out to be safe
                updateUIForLoggedOut();
                return;
            }

            const data = await response.json();

            // Update localStorage with the latest data from the server
            localStorage.setItem(SESSION_KEYS.token, token); // The token is still valid
            localStorage.setItem(SESSION_KEYS.username, data.username);
            localStorage.setItem(SESSION_KEYS.isAdmin, data.isAdmin);
            const canTransfer = data.canTransfer === true || data.canTransfer === 1;
            localStorage.setItem(SESSION_KEYS.canTransfer, canTransfer ? "true" : "false");
            const canViewClips = data.canViewClips === true || data.canViewClips === 1;
            localStorage.setItem(SESSION_KEYS.canViewClips, canViewClips ? "true" : "false");
            if (data.profile_picture_filename) {
                localStorage.setItem(SESSION_KEYS.profilePictureFilename, data.profile_picture_filename);
            } else {
                localStorage.removeItem(SESSION_KEYS.profilePictureFilename);
            }

            applyQualityPreference(data.preferred_quality || DEFAULT_VIDEO_QUALITY);

            updateUIForLoggedIn(data.username, data.profile_picture_filename);
        } catch (error) {
            console.error('Hiba a munkamenet ellenőrzésekor:', error);
            // If there's a network error or the server is down, log out
            updateUIForLoggedOut();
        }
    }

    const avatarCropperModal = document.getElementById('avatarCropperModal');
    const avatarCropperImage = document.getElementById('avatarCropperImage');
    const avatarCropperCancel = document.getElementById('avatarCropperCancel');
    const avatarCropperSave = document.getElementById('avatarCropperSave');
    const avatarZoomRange = document.getElementById('avatarZoomRange');
    let avatarPreviewObjectUrl = null;
    let avatarCropperInstance = null;
    let croppedAvatarBlob = null;
    let avatarOriginalFileName = '';

    const closeAvatarCropper = (resetSelection = false) => {
        if (avatarCropperModal) {
            avatarCropperModal.classList.remove('open');
            avatarCropperModal.setAttribute('aria-hidden', 'true');
        }

        if (avatarCropperInstance) {
            avatarCropperInstance.destroy();
            avatarCropperInstance = null;
        }

        if (resetSelection && avatarInput) {
            avatarInput.value = '';
        }

        if (avatarZoomRange) {
            avatarZoomRange.value = '1';
        }

        if (avatarCropperImage) {
            avatarCropperImage.src = '';
        }
    };

    if (avatarInput && profileAvatarPreview && avatarCropperImage && avatarCropperModal) {
        avatarInput.addEventListener('change', () => {
            const file = avatarInput.files[0];

            if (!file) {
                return;
            }

            avatarOriginalFileName = file.name;
            croppedAvatarBlob = null;

            if (avatarUploadStatus) {
                avatarUploadStatus.textContent = '';
            }

            const reader = new FileReader();
            reader.onload = () => {
                avatarCropperImage.src = reader.result;

                if (avatarCropperInstance) {
                    avatarCropperInstance.destroy();
                }

                avatarCropperInstance = new Cropper(avatarCropperImage, {
                    aspectRatio: 1,
                    viewMode: 1,
                    dragMode: 'move',
                    autoCropArea: 1,
                    ready() {
                        if (avatarZoomRange) {
                            avatarZoomRange.value = '1';
                        }
                        avatarCropperInstance.zoomTo(1);
                    },
                });

                avatarCropperModal.classList.add('open');
                avatarCropperModal.setAttribute('aria-hidden', 'false');
            };

            reader.readAsDataURL(file);
        });
    }

    if (avatarZoomRange) {
        avatarZoomRange.addEventListener('input', (event) => {
            if (avatarCropperInstance) {
                const zoomValue = parseFloat(event.target.value);
                avatarCropperInstance.zoomTo(zoomValue);
            }
        });
    }

    if (avatarCropperCancel) {
        avatarCropperCancel.addEventListener('click', () => {
            croppedAvatarBlob = null;
            closeAvatarCropper(true);
        });
    }

    if (avatarCropperSave) {
        avatarCropperSave.addEventListener('click', () => {
            if (!avatarCropperInstance) return;

            const canvas = avatarCropperInstance.getCroppedCanvas({ width: 512, height: 512, imageSmoothingQuality: 'high' });
            canvas.toBlob((blob) => {
                if (!blob) return;

                croppedAvatarBlob = blob;

                if (avatarPreviewObjectUrl) {
                    URL.revokeObjectURL(avatarPreviewObjectUrl);
                }

                avatarPreviewObjectUrl = URL.createObjectURL(blob);
                profileAvatarPreview.src = avatarPreviewObjectUrl;
                profileAvatarPreview.dataset.override = 'true';
                if (avatarUploadStatus) {
                    avatarUploadStatus.textContent = '';
                }

                closeAvatarCropper();
                if (avatarInput) {
                    avatarInput.value = '';
                }
            }, 'image/png');
        });
    }

    if (uploadAvatarBtn) {
        uploadAvatarBtn.addEventListener('click', async () => {
            if (!isUserLoggedIn()) {
                alert("A feltöltéshez be kell jelentkezned.");
                return;
            }

            const file = avatarInput.files[0];
            if (!file && !croppedAvatarBlob) {
                alert("Válassz ki egy képfájlt a feltöltéshez.");
                return;
            }

            const formData = new FormData();
            if (croppedAvatarBlob) {
                formData.append('avatar', croppedAvatarBlob, avatarOriginalFileName || 'avatar.png');
            } else if (file) {
                formData.append('avatar', file);
            }

            uploadAvatarBtn.disabled = true;
            avatarUploadStatus.textContent = "Feltöltés folyamatban...";

            try {
                const response = await fetch('/api/profile/upload-avatar', {
                    method: 'POST',
                    headers: buildAuthHeaders(),
                    body: formData,
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.message || 'Nem sikerült feltölteni a profilképet.');
                }

                avatarUploadStatus.textContent = result.message;
                avatarInput.value = '';
                if (avatarPreviewObjectUrl) {
                    URL.revokeObjectURL(avatarPreviewObjectUrl);
                    avatarPreviewObjectUrl = null;
                }
                delete profileAvatarPreview.dataset.override;
                croppedAvatarBlob = null;
                avatarOriginalFileName = '';
                await ensureSessionOnLoad(); // Refresh session data to get new avatar filename
            } catch (error) {
                console.error('Profilkép feltöltési hiba:', error);
                avatarUploadStatus.textContent = error.message;
            } finally {
                uploadAvatarBtn.disabled = false;
            }
        });
    }

    const updateUsernameForm = document.getElementById('updateUsernameForm');
    if (updateUsernameForm) {
        updateUsernameForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newUsername = document.getElementById('newUsername').value;

            try {
                const res = await fetch('/api/profile/update-name', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...buildAuthHeaders() },
                    body: JSON.stringify({ newUsername }),
                });

                const data = await res.json();
                if (res.ok) {
                    alert(data.message);
                    await ensureSessionOnLoad();
                } else {
                    alert(data.message);
                }
            } catch (error) {
                alert('Hiba történt a felhasználónév frissítése során.');
            }
        });
    }

    const updatePasswordForm = document.getElementById('updatePasswordForm');
    if (updatePasswordForm) {
        updatePasswordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;

            try {
                const res = await fetch('/api/profile/update-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...buildAuthHeaders() },
                    body: JSON.stringify({ currentPassword, newPassword }),
                });

                const data = await res.json();
                if (res.ok) {
                    alert(data.message);
                    updatePasswordForm.reset();
                } else {
                    alert(data.message);
                }
            } catch (error) {
                alert('Hiba történt a jelszó frissítése során.');
            }
        });
    }
  </script>

    <script>
      const summaryToggleBtn = document.getElementById("summaryToggleBtn");
      const summaryCard = document.getElementById("summaryCard");
      const summaryCloseBtn = document.getElementById("summaryCloseBtn");
      const videoGridContainer = document.getElementById("video-grid-container");
      const videoPagination = document.getElementById("video-pagination");
      const clipSection = document.getElementById("klipek");
      const clipsPermissionOverlay = document.getElementById("clipsPermissionOverlay");
      const showUploadModalBtn = document.getElementById("showUploadModalBtn");
      const uploadModal = document.getElementById("uploadModal");
      const closeUploadModalBtn = document.getElementById("closeUploadModal");
      const dropZone = document.getElementById("drop-zone");
      const uploadQueueContainer = document.getElementById("uploadQueueContainer");
      const fileInput = document.getElementById("fileInput");
      const addFilesBtn = document.getElementById("addFilesBtn");
      const cancelUploadBtn = document.getElementById("cancelUploadBtn");
      const uploadBtn = document.getElementById("uploadBtn");
      const uploadStatus = document.getElementById("uploadStatus");
      const uploadProgress = document.getElementById("uploadProgress");
      const uploadProgressFill = document.getElementById("uploadProgressFill");
      const uploadProgressCount = document.getElementById("uploadProgressCount");
      const uploadProgressEta = document.getElementById("uploadProgressEta");
      const uploadProgressDetails = document.getElementById("uploadProgressDetails");
      const selectedFileName = document.getElementById("selectedFileName");
      const uploadSummary = document.getElementById("uploadSummary");
      const uploadToast = document.getElementById("uploadToast");
      const clipToast = document.getElementById("clipToast");
      const videoPlayerModal = document.getElementById("videoPlayerModal");
      const modalVideoPlayer = document.getElementById("modalVideoPlayer");
      const modalVideoTitle = document.getElementById("modalVideoTitle");
      const closeVideoModalBtn = document.getElementById("closeVideoModalBtn");
      const prevVideoBtn = document.getElementById("prevVideoBtn");
      const nextVideoBtn = document.getElementById("nextVideoBtn");
      const MAX_UPLOAD_FILES = 100;
      const globalTagSelect = document.getElementById("globalTagSelect");
      const videoSearchInput = document.getElementById("videoSearchInput");
      const tagFilterSelect = document.getElementById("tagFilterSelect");
      const sortOrderSelect = document.getElementById("sortOrderSelect");
      const videoQualitySelect = document.getElementById("videoQualitySelect");
      const pageSizeSelect = document.getElementById("pageSizeSelect");
      const filterResetBtn = document.getElementById("filterResetBtn");
      const createTagWrapper = document.getElementById("createTagWrapper");
      const newTagNameInput = document.getElementById("newTagName");
      const newTagColorInput = document.getElementById("newTagColor");
      const tagColorButton = document.getElementById("tagColorButton");
      const createTagButton = document.getElementById("createTagButton");
      const deleteTagButton = document.getElementById("deleteTagButton");
      const createTagStatus = document.getElementById("createTagStatus");
      const DEFAULT_TAG_COLOR = "#5865f2";
      let uploadQueue = [];
      const fileSignatures = new Set();
      const UPLOAD_ABORT_MESSAGE = "UPLOAD_ABORTED";
      let isUploadCancelled = false;
      let isUploading = false;
      let currentUploadXhr = null;
      let uploadedVideoIds = [];
      let clipToastTimeout = null;
      let availableTags = [];
      const VIDEO_QUALITY_KEY = "videoQualityPreference";
      const DEFAULT_VIDEO_QUALITY = "1080p";
      const ALLOWED_VIDEO_QUALITIES = ["1080p", "720p"];
      const VIDEO_PAGE_SIZE_KEY = "videoPageSize";
      const VIDEO_SORT_ORDER_KEY = "videoSortOrder";
      const savedPageSize = Number.parseInt(localStorage.getItem(VIDEO_PAGE_SIZE_KEY), 10);
      const savedSortOrder = localStorage.getItem(VIDEO_SORT_ORDER_KEY);
      const savedQuality = localStorage.getItem(VIDEO_QUALITY_KEY);
      const videoFilters = {
        page: 1,
        limit: [12, 24, 40, 80].includes(savedPageSize) ? savedPageSize : 24,
        search: "",
        tag: "",
        sort: savedSortOrder === "oldest" ? "oldest" : "newest",
      };
      let currentVideoQuality = ALLOWED_VIDEO_QUALITIES.includes(savedQuality)
        ? savedQuality
        : DEFAULT_VIDEO_QUALITY;
      let videoSearchTimeout = null;
      let currentVideoList = [];
      let currentVideoIndex = 0;

      if (summaryToggleBtn && summaryCard) {
        summaryToggleBtn.addEventListener("click", () => {
          summaryCard.classList.add("summary-card--visible");
          summaryCard.setAttribute("aria-hidden", "false");
          summaryToggleBtn.setAttribute("aria-expanded", "true");
          summaryToggleBtn.classList.add("is-hidden");

          if (summaryCloseBtn) {
            summaryCloseBtn.focus();
          }
        });
      }

      if (summaryCloseBtn && summaryCard && summaryToggleBtn) {
        summaryCloseBtn.addEventListener("click", () => {
          summaryCard.classList.remove("summary-card--visible");
          summaryCard.setAttribute("aria-hidden", "true");
          summaryToggleBtn.setAttribute("aria-expanded", "false");
          summaryToggleBtn.classList.remove("is-hidden");
          summaryToggleBtn.focus();
        });
      }

      if (pageSizeSelect) {
        pageSizeSelect.value = String(videoFilters.limit);
      }

      if (sortOrderSelect) {
        sortOrderSelect.value = videoFilters.sort;
      }

      applyQualityPreference(currentVideoQuality);

      function isAdminUser() {
        return localStorage.getItem(ADMIN_SESSION_KEY) === "true";
      }

      function hasFileTransferPermission() {
        return isUserLoggedIn() && localStorage.getItem(SESSION_KEYS.canTransfer) === "true";
      }

      function hasClipAccess() {
        return isUserLoggedIn() && localStorage.getItem(SESSION_KEYS.canViewClips) === "true";
      }

      function updateClipAccessUI() {
        const allowed = hasClipAccess();

        if (clipSection) {
          clipSection.classList.toggle("permission-blocked", !allowed);
        }

        if (clipsPermissionOverlay) {
          clipsPermissionOverlay.style.display = allowed ? "none" : "flex";
          clipsPermissionOverlay.setAttribute("aria-hidden", allowed ? "true" : "false");
        }

        if (!allowed) {
          if (videoGridContainer) {
            videoGridContainer.innerHTML = "";
          }
          if (videoPagination) {
            videoPagination.innerHTML = "";
          }
        }

        if (showUploadModalBtn) {
          showUploadModalBtn.disabled = !allowed;
          showUploadModalBtn.title = allowed ? "" : "Jogosultság szükséges a klipek eléréséhez.";
        }
      }

      function getAccessibleNavLinks() {
        return Array.from(document.querySelectorAll("nav a")).filter((link) => {
          const requiresAdmin = link.dataset.requiresAdmin === "true";
          const requiresTransfer = link.dataset.requiresTransfer === "true";

          if (requiresAdmin && !isAdminUser()) {
            return false;
          }

          if (requiresTransfer && !hasFileTransferPermission()) {
            return false;
          }

          return true;
        });
      }

      function updateProgramAdminControls() {
        if (addProgramBtn) {
          addProgramBtn.style.display = isAdminUser() ? "inline-flex" : "none";
        }

        if (!programsContainer) {
          return;
        }

        programsContainer.querySelectorAll(".program-card").forEach((card) => {
          card.classList.toggle("program-card--admin", isAdminUser());
        });
      }

      function setProgramUploadMode(mode, program = null) {
        const isEditMode = mode === "edit";
        editingProgram = isEditMode ? program : null;

        if (programUploadTitle) {
          programUploadTitle.textContent = isEditMode ? "Program szerkesztése" : "Új Program Feltöltése";
        }

        if (submitProgramUploadBtn) {
          submitProgramUploadBtn.textContent = isEditMode ? "Frissítés" : "Mentés";
        }

        if (programFileInput) {
          if (isEditMode) {
            programFileInput.removeAttribute("required");
          } else {
            programFileInput.setAttribute("required", "required");
          }
          programFileInput.value = "";
        }

        if (!isEditMode && programFileName) {
          programFileName.textContent = "Nincs kiválasztva fájl.";
        }
      }

      function resetProgramUploadModal() {
        if (programUploadForm) {
          programUploadForm.reset();
        }

        if (programFileName) {
          programFileName.textContent = "Nincs kiválasztva fájl.";
        }

        if (programImageCropper) {
          programImageCropper.destroy();
          programImageCropper = null;
        }

        if (programImageObjectUrl) {
          URL.revokeObjectURL(programImageObjectUrl);
          programImageObjectUrl = null;
        }

        if (programImagePreview) {
          programImagePreview.removeAttribute("src");
        }
      }

      function closeProgramUploadModal() {
        if (programUploadModal) {
          programUploadModal.style.display = "none";
        }

        setProgramUploadMode("create");
        resetProgramUploadModal();
      }

      function renderProgramCard(program) {
        const card = document.createElement("article");
        card.className = "program-card";
        if (isAdminUser()) {
          card.classList.add("program-card--admin");
        }

        const thumb = document.createElement("img");
        thumb.className = "program-card__thumbnail";
        thumb.src = program?.image_filename
          ? `/uploads/programs/images/${program.image_filename}`
          : "program_icons/default-avatar.png";
        thumb.alt = `${program?.name || "Program"} borítókép`;
        card.appendChild(thumb);

        const body = document.createElement("div");
        body.className = "program-card__body";

        const title = document.createElement("h3");
        title.className = "program-card__title";
        title.textContent = program?.name || "Program";

        const description = document.createElement("p");
        description.className = "program-card__description";
        description.textContent = program?.description || "Nincs leírás megadva.";

        const meta = document.createElement("div");
        meta.className = "program-card__meta";
        const createdAt = program?.created_at ? new Date(program.created_at) : null;
        const downloadInfo = document.createElement("span");
        downloadInfo.textContent = `Letöltések: ${Number(program?.download_count) || 0}`;
        meta.appendChild(downloadInfo);
        if (createdAt) {
          const dateInfo = document.createElement("span");
          dateInfo.textContent = createdAt.toLocaleDateString("hu-HU");
          meta.appendChild(dateInfo);
        }

        const actions = document.createElement("div");
        actions.className = "program-card__actions";

        const downloadBtn = document.createElement("button");
        downloadBtn.type = "button";
        downloadBtn.className = "primary-button program-card__download";
        downloadBtn.textContent = "Letöltés";
        downloadBtn.addEventListener("click", () => handleProgramDownload(program));

        actions.appendChild(downloadBtn);

        body.appendChild(title);
        body.appendChild(description);
        body.appendChild(meta);
        body.appendChild(actions);

        card.appendChild(body);

        if (isAdminUser()) {
          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.className = "program-card__edit";
          editBtn.setAttribute("aria-label", "Program szerkesztése");
          editBtn.textContent = "✎";
          editBtn.addEventListener("click", () => openProgramEditModal(program));
          card.appendChild(editBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "program-card__delete";
          deleteBtn.setAttribute("aria-label", "Program törlése");
          deleteBtn.textContent = "✕";
          deleteBtn.addEventListener("click", () => handleProgramDelete(program.id, card, deleteBtn));
          card.appendChild(deleteBtn);
        }

        return card;
      }

      async function loadPrograms() {
        if (!programsContainer) {
          return;
        }

        programsContainer.innerHTML = "<p class='programs-empty'>Betöltés...</p>";

        try {
          const response = await fetch("/api/programs");
          if (!response.ok) {
            throw new Error("Nem sikerült lekérni a programokat.");
          }

          const programs = await response.json();
          programsContainer.innerHTML = "";

          if (!Array.isArray(programs) || programs.length === 0) {
            programsContainer.innerHTML = "<p class='programs-empty'>Még nincs feltöltött program.</p>";
            updateProgramAdminControls();
            return;
          }

          programs.forEach((program) => {
            const card = renderProgramCard(program);
            programsContainer.appendChild(card);
          });

          updateProgramAdminControls();
        } catch (error) {
          console.error("Programok betöltési hiba:", error);
          programsContainer.innerHTML =
            "<p class='programs-empty'>Nem sikerült betölteni a programokat. Próbáld meg később.</p>";
        }
      }

      async function handleProgramDownload(program) {
        if (!program?.id) {
          return;
        }

        const downloadUrl = `/api/programs/${program.id}/download`;
        try {
          const response = await fetch(downloadUrl);

          if (response.status === 429) {
            const payload = await response.json().catch(() => ({}));
            alert(payload.message || "Túllépted a letöltési keretet (Max 3/óra, 10/nap).");
            return;
          }

          if (!response.ok) {
            throw new Error("Nem sikerült letölteni a programot.");
          }

          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = objectUrl;
          a.download = program?.original_filename || `${program?.name || "program"}.exe`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(objectUrl);
        } catch (error) {
          console.error("Program letöltési hiba:", error);
          alert(error.message || "Nem sikerült letölteni a programot.");
        }
      }

      async function handleProgramDelete(programId, card, button) {
        if (!isAdminUser()) {
          alert("Csak admin törölhet programot.");
          return;
        }

        if (!confirm("Biztosan törlöd ezt a programot?")) {
          return;
        }

        const originalText = button?.textContent;
        if (button) {
          button.disabled = true;
          button.textContent = "...";
        }

        try {
          const response = await fetch(`/api/programs/${programId}`, {
            method: "DELETE",
            headers: buildAuthHeaders(),
          });

          const payload = await response.json().catch(() => ({}));

          if (!response.ok) {
            const message = payload?.message || "Nem sikerült törölni a programot.";
            throw new Error(message);
          }

          if (card) {
            card.remove();
          }

          if (!programsContainer?.children.length) {
            programsContainer.innerHTML = "<p class='programs-empty'>Még nincs feltöltött program.</p>";
          }
        } catch (error) {
          console.error("Program törlési hiba:", error);
          alert(error.message || "Nem sikerült törölni a programot.");
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = originalText || "✕";
          }
        }
      }

      function formatDate(dateString) {
        if (!dateString) return "Ismeretlen";
        const date = new Date(dateString);
        return date.toLocaleDateString("hu-HU", {
          year: "numeric",
          month: "short",
          day: "numeric",
        });
      }

      function getSelectValues(selectElement) {
        if (!selectElement) return [];
        return Array.from(selectElement.selectedOptions || [])
          .map((option) => Number(option.value))
          .filter((val) => Number.isFinite(val));
      }

      function normalizeColor(color) {
        if (!color || typeof color !== "string") return DEFAULT_TAG_COLOR;
        const trimmed = color.trim();
        return /^#([0-9a-fA-F]{6})$/.test(trimmed) ? trimmed.toUpperCase() : DEFAULT_TAG_COLOR;
      }

      function styleTagOption(option, color) {
        const safeColor = normalizeColor(color);
        option.style.background = `linear-gradient(90deg, ${safeColor} 0 10px, rgba(255, 255, 255, 0.04) 10px 100%)`;
        option.style.borderLeft = `6px solid ${safeColor}`;
      }

      function renderGlobalTagSelect() {
        if (!globalTagSelect) return;
        const currentSelection = getSelectValues(globalTagSelect);
        globalTagSelect.innerHTML = "";
        availableTags.forEach((tag) => {
          const option = document.createElement("option");
          option.value = String(tag.id);
          option.textContent = tag.name;
          option.selected = currentSelection.includes(tag.id);
          styleTagOption(option, tag.color);
          globalTagSelect.appendChild(option);
        });
      }

      function createQueueTagSelect(selectedValues = [], onChange) {
        const normalized = Array.isArray(selectedValues) ? [...selectedValues] : [];
        const container = document.createElement("div");
        container.className = "tag-pill-list";

        const syncSelection = () => {
          container.querySelectorAll(".tag-pill").forEach((pill) => {
            const tagId = Number(pill.dataset.tagId);
            pill.classList.toggle("tag-pill--selected", normalized.includes(tagId));
          });
        };

        const toggleTag = (tagId) => {
          const idx = normalized.indexOf(tagId);
          if (idx >= 0) {
            normalized.splice(idx, 1);
          } else {
            normalized.push(tagId);
          }
          syncSelection();
          if (typeof onChange === "function") {
            onChange([...normalized]);
          }
        };

        availableTags.forEach((tag) => {
          const pill = document.createElement("button");
          pill.type = "button";
          pill.className = "tag-pill";
          pill.dataset.tagId = String(tag.id);
          pill.style.setProperty("--tag-color", normalizeColor(tag.color));
          pill.innerHTML = `<span class="tag-pill__dot"></span><span class="tag-pill__label">${tag.name}</span>`;
          pill.addEventListener("click", () => {
            toggleTag(tag.id);
            pill.blur();
            pill.dispatchEvent(new CustomEvent("tagchange", { bubbles: true }));
          });
          container.appendChild(pill);
        });

        container.getSelectedValues = () => [...normalized];
        container.setSelectedValues = (values) => {
          if (Array.isArray(values)) {
            normalized.splice(0, normalized.length, ...values);
            syncSelection();
          }
        };

        syncSelection();
        return container;
      }

      function populateTagSelect() {
        if (!tagFilterSelect) return;
        const currentValue = tagFilterSelect.value;
        tagFilterSelect.innerHTML = '<option value="">Összes címke</option>';
        availableTags.forEach((tag) => {
          const option = document.createElement("option");
          option.value = String(tag.id);
          option.textContent = tag.name;
          tagFilterSelect.appendChild(option);
        });
        if (currentValue) {
          tagFilterSelect.value = currentValue;
        }
      }

      async function fetchTags() {
        if (!hasClipAccess()) {
          availableTags = [];
          populateTagSelect();
          renderGlobalTagSelect();
          return;
        }
        try {
          const response = await fetch("/api/tags");
          if (!response.ok) throw new Error("Nem sikerült lekérni a címkéket.");
          const payload = await response.json();
          availableTags = Array.isArray(payload)
            ? payload.map((tag) => ({ ...tag, color: normalizeColor(tag.color) }))
            : [];
          populateTagSelect();
          renderGlobalTagSelect();
          renderUploadQueue();
          if (createTagWrapper) {
            createTagWrapper.style.display = isAdminUser() ? "block" : "none";
          }
        } catch (error) {
          console.error(error);
        }
      }

      function updateUploadSummary() {
        if (!uploadSummary || !selectedFileName) return;
        const count = uploadQueue.length;
        if (!count) {
          uploadSummary.textContent = "Nincs kiválasztott fájl.";
          selectedFileName.textContent = "Nincs kiválasztott fájl.";
          return;
        }
        uploadSummary.textContent = `${count} fájl kiválasztva.`;
        selectedFileName.textContent = uploadSummary.textContent;
      }

      function formatBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
          value /= 1024;
          unitIndex += 1;
        }
        const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
        return `${value.toFixed(precision)} ${units[unitIndex]}`;
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds < 0) return "--";
        const totalSeconds = Math.ceil(seconds);
        const minutes = Math.floor(totalSeconds / 60);
        const remainingSeconds = totalSeconds % 60;
        return `${minutes}:${String(remainingSeconds).padStart(2, "0")}`;
      }

      function resetUploadProgress() {
        if (uploadProgress) {
          uploadProgress.style.display = "none";
        }
        if (uploadProgressFill) {
          uploadProgressFill.style.width = "0%";
        }
        if (uploadProgressCount) {
          uploadProgressCount.textContent = "0 / 0 klip";
        }
        if (uploadProgressEta) {
          uploadProgressEta.textContent = "Hátralévő idő: --";
        }
        if (uploadProgressDetails) {
          uploadProgressDetails.textContent = "";
        }
      }

      async function rollbackUploadedVideos(videoIds) {
        const normalizedIds = Array.isArray(videoIds)
          ? Array.from(new Set(videoIds.map((id) => Number(id)).filter(Number.isFinite)))
          : [];

        if (!normalizedIds.length) {
          return { deletedVideoIds: [] };
        }

        const response = await fetch("/api/videos/cancel", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...buildAuthHeaders() },
          body: JSON.stringify({ videoIds: normalizedIds }),
        });

        const result = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(result?.message || "Nem sikerült visszavonni a feltöltött videókat.");
        }

        return result;
      }

      function updateUploadProgressUI({
        uploadedBytes,
        totalBytes,
        completedFiles,
        totalFiles,
        etaSeconds,
      }) {
        if (!uploadProgress || !uploadProgressFill || !uploadProgressCount || !uploadProgressEta) {
          return;
        }

        const safeTotalBytes = totalBytes || 0;
        const percent = safeTotalBytes > 0 ? Math.min(100, (uploadedBytes / safeTotalBytes) * 100) : 0;

        uploadProgress.style.display = "flex";
        uploadProgressFill.style.width = `${percent}%`;
        uploadProgressCount.textContent = `${completedFiles} / ${totalFiles} klip`;
        uploadProgressEta.textContent = `Hátralévő idő: ${formatDuration(etaSeconds)}`;

        if (uploadProgressDetails) {
          const remainingBytes = Math.max(safeTotalBytes - uploadedBytes, 0);
          uploadProgressDetails.textContent = `${formatBytes(uploadedBytes)} / ${formatBytes(
            safeTotalBytes
          )} • Hátra: ${formatBytes(remainingBytes)}`;
        }
      }

      function removeFromQueue(signature) {
        uploadQueue = uploadQueue.filter((item) => item.signature !== signature);
        fileSignatures.delete(signature);
        renderUploadQueue();
        updateUploadSummary();
        if (uploadBtn) {
          uploadBtn.disabled = uploadQueue.length === 0;
        }
      }

      function showUploadToast(message) {
        if (!uploadToast) return;
        uploadToast.textContent = message;
        uploadToast.classList.add("upload-toast--visible");
        const modalContent = uploadModal?.querySelector(".upload-modal-content");
        if (modalContent) {
          modalContent.classList.remove("shake");
          modalContent.offsetWidth;
          modalContent.classList.add("shake");
        }
        setTimeout(() => uploadToast.classList.remove("upload-toast--visible"), 1800);
      }

      function renderUploadQueue() {
        if (!uploadQueueContainer) return;
        uploadQueueContainer.innerHTML = "";
        if (dropZone) {
          uploadQueueContainer.appendChild(dropZone);
        }

        uploadQueue.forEach((item) => {
          const row = document.createElement("div");
          row.className = "upload-queue-item";

          const thumbnail = document.createElement("div");
          thumbnail.className = "queue-thumbnail";
          if (item.thumbnail) {
            const img = document.createElement("img");
            img.src = item.thumbnail;
            img.alt = item.displayName || item.file.name;
            thumbnail.appendChild(img);
          } else {
            thumbnail.textContent = "📹";
          }

          const details = document.createElement("div");
          details.className = "queue-details";

          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = item.displayName || item.file.name;
          nameInput.placeholder = "Videó neve";
          nameInput.addEventListener("input", (event) => {
            item.displayName = event.target.value || item.file.name;
            updateUploadSummary();
          });
          details.appendChild(nameInput);

          const tagSelector = createQueueTagSelect(item.tags || [], (values) => {
            item.tags = values;
          });
          tagSelector.setAttribute("aria-label", "Címke kiválasztása");
          details.appendChild(tagSelector);

          const actions = document.createElement("div");
          actions.className = "queue-actions";

          const removeBtn = document.createElement("button");
          removeBtn.className = "queue-remove";
          removeBtn.type = "button";
          removeBtn.innerHTML = "&times;";
          removeBtn.addEventListener("click", () => removeFromQueue(item.signature));
          actions.appendChild(removeBtn);

          row.appendChild(thumbnail);
          row.appendChild(details);
          row.appendChild(actions);

          uploadQueueContainer.appendChild(row);
        });
      }

      function getFileSignature(file) {
        return `${file.name}-${file.size}-${file.lastModified}`;
      }

      function generateVideoThumbnail(file) {
        return new Promise((resolve, reject) => {
          const video = document.createElement("video");
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          const url = URL.createObjectURL(file);
          video.src = url;
          video.preload = "metadata";
          video.muted = true;
          video.playsInline = true;

          const cleanup = () => URL.revokeObjectURL(url);

          video.addEventListener("loadeddata", () => {
            try {
              const captureTime = Math.min(1, Math.max(0, video.duration || 1));
              video.currentTime = captureTime;
            } catch (error) {
              cleanup();
              reject(error);
            }
          });

          video.addEventListener("seeked", () => {
            try {
              canvas.width = 160;
              canvas.height = 90;
              context?.drawImage(video, 0, 0, canvas.width, canvas.height);
              const dataUrl = canvas.toDataURL("image/png");
              cleanup();
              resolve(dataUrl);
            } catch (error) {
              cleanup();
              reject(error);
            }
          });

          video.addEventListener("error", (error) => {
            cleanup();
            reject(error);
          });
        });
      }

      function normalizeQualityPreference(quality) {
        if (!quality) return DEFAULT_VIDEO_QUALITY;
        return ALLOWED_VIDEO_QUALITIES.includes(quality) ? quality : DEFAULT_VIDEO_QUALITY;
      }

      function applyQualityPreference(quality, { persistLocally = true } = {}) {
        const normalizedQuality = normalizeQualityPreference(quality);
        currentVideoQuality = normalizedQuality;

        if (persistLocally) {
          localStorage.setItem(VIDEO_QUALITY_KEY, normalizedQuality);
        }

        if (videoQualitySelect) {
          videoQualitySelect.value = normalizedQuality;
        }

        return normalizedQuality;
      }

      function appendQualitySuffix(filename, suffix) {
        if (typeof filename !== "string") return "";
        const dotIndex = filename.lastIndexOf(".");
        if (dotIndex === -1) {
          return `${filename}${suffix}`;
        }
        return `${filename.slice(0, dotIndex)}${suffix}${filename.slice(dotIndex)}`;
      }

      function getPreferredVideoSource(video, qualityPreference) {
        const normalizedQuality = normalizeQualityPreference(qualityPreference);
        const baseSource = video?.filename ? `/uploads/${video.filename}` : "";
        const has720pAvailable = Number(video?.has_720p) === 1 || video?.has_720p === true || video?.has_720p === "1";

        if (normalizedQuality === "720p" && has720pAvailable && video?.filename) {
          const hasOriginalFolder = video.filename.includes("/eredeti/");
          const targetPath = hasOriginalFolder
            ? appendQualitySuffix(video.filename.replace("/eredeti/", "/720p/"), "_720p")
            : appendQualitySuffix(video.filename, "_720p");

          return { src: `/uploads/${targetPath}`, has720pAvailable, prefers720p: true };
        }

        return { src: baseSource, has720pAvailable, prefers720p: normalizedQuality === "720p" };
      }

      function showClipToast(message) {
        if (!clipToast) return;
        clipToast.textContent = message;
        clipToast.classList.add("upload-toast--visible");
        if (clipToastTimeout) {
          clearTimeout(clipToastTimeout);
        }
        clipToastTimeout = setTimeout(() => clipToast.classList.remove("upload-toast--visible"), 2200);
      }

      async function saveQualityPreferenceToServer(quality) {
        const response = await fetch("/api/profile/update-quality", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...buildAuthHeaders(),
          },
          body: JSON.stringify({ quality: normalizeQualityPreference(quality) }),
        });

        const result = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(result?.message || "Nem sikerült menteni a minőségi beállítást.");
        }

        return result;
      }

      async function loadVideos() {
        if (!videoGridContainer) {
          return;
        }

        if (!hasClipAccess()) {
          updateClipAccessUI();
          return;
        }

        videoGridContainer.innerHTML = "";
        if (videoPagination) videoPagination.innerHTML = "";

        const params = new URLSearchParams();
        Object.entries(videoFilters).forEach(([key, value]) => {
          if (value) params.append(key, value);
        });

        try {
          const response = await fetch(`/api/videos?${params.toString()}`, {
            headers: buildAuthHeaders(),
          });

          if (response.status === 401) {
            updateUIForLoggedOut();
            throw new Error("Be kell jelentkezned a klipek megtekintéséhez.");
          }

          if (response.status === 403) {
            localStorage.setItem(SESSION_KEYS.canViewClips, "false");
            updateClipAccessUI();
            throw new Error("Nincs jogosultságod a klipek megtekintéséhez.");
          }

          if (!response.ok) {
            throw new Error("Nem sikerült betölteni a videókat.");
          }

          const { data, pagination } = await response.json();
          videoFilters.page = pagination?.currentPage || videoFilters.page;

          currentVideoList = Array.isArray(data) ? data : [];

          if (!Array.isArray(data) || data.length === 0) {
            videoGridContainer.innerHTML = "<p>Még senki nem töltött fel videót.</p>";
            return;
          }

          renderVideoGrid(data);
          renderPagination(pagination);
        } catch (error) {
          console.error("Videók betöltési hibája:", error);
          currentVideoList = [];
          videoGridContainer.innerHTML = "<p>Nem sikerült betölteni a videókat.</p>";
        }
      }

      function cleanVideoTitle(rawTitle) {
        if (!rawTitle) return "";

        const trimmed = rawTitle.trim();
        const looksLikeMojibake = /[Ã�Â]/.test(trimmed);
        if (looksLikeMojibake) {
          const decoded = new TextDecoder("utf-8").decode(
            Uint8Array.from(trimmed.split("").map((char) => char.charCodeAt(0)))
          );
          if (decoded && !decoded.includes("�")) {
            return decoded.replace(/\.[^.]+$/i, "").trim();
          }
        }

        return trimmed.replace(/\.[^.]+$/i, "").trim();
      }

      function renderVideoGrid(videos) {
        videoGridContainer.innerHTML = "";
        videos.forEach((video, index) => {
          const card = document.createElement("div");
          card.className = "video-card";

          const title = document.createElement("p");
          title.className = "video-card__title";
          const rawTitle = video.original_name || video.filename;
          title.textContent = cleanVideoTitle(rawTitle) || "Névtelen videó";

          const videoElement = document.createElement("video");
          videoElement.poster = video.thumbnail_filename
            ? `/uploads/${video.thumbnail_filename}`
            : "";
          videoElement.dataset.src = `/uploads/${video.filename}`;
          videoElement.controls = false;
          videoElement.removeAttribute("controls");
          videoElement.preload = "none";
          videoElement.playsInline = true;
          videoElement.setAttribute("playsinline", "");
          videoElement.setAttribute("webkit-playsinline", "");

          let hasPlaybackError = false;

          videoElement.addEventListener("click", () => {
            openVideoModal(index);
          });

          videoElement.addEventListener("error", () => {
            if (hasPlaybackError) {
              return;
            }

            hasPlaybackError = true;
            card.classList.add("video-card--error");

            const errorMessage = document.createElement("p");
            errorMessage.className = "video-card__error";
            errorMessage.textContent =
              "Nem sikerült betölteni a videót. Frissítsd az oldalt vagy próbáld meg később.";
            card.appendChild(errorMessage);
          });

          videoElement.addEventListener("loadeddata", () => {
            card.classList.remove("video-card--error");
            hasPlaybackError = false;
            const existingError = card.querySelector(".video-card__error");
            if (existingError) {
              existingError.remove();
            }
          });

          const meta = document.createElement("div");
          meta.className = "video-card__meta";
          const uploader = document.createElement("span");
          uploader.textContent = `Feltöltötte: ${video.username || "Ismeretlen"}`;
          const uploadedAt = document.createElement("span");
          const displayedDate = video.content_created_at || video.uploaded_at;
          uploadedAt.textContent = formatDate(displayedDate);
          meta.append(uploader, uploadedAt);

          const tagList = document.createElement("div");
          tagList.className = "tag-list";
          (video.tags || []).forEach((tag) => {
            const chip = document.createElement("span");
            chip.className = "tag-chip";
            chip.style.setProperty("--tag-color", normalizeColor(tag.color));
            chip.textContent = tag.name;
            tagList.appendChild(chip);
          });

          card.appendChild(title);
          card.appendChild(videoElement);
          card.appendChild(meta);
          if (tagList.childElementCount) {
            card.appendChild(tagList);
          }

          if (isAdminUser()) {
            const actions = document.createElement("div");
            actions.className = "video-card__actions";
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "delete-btn";
            deleteBtn.textContent = "Törlés";
            deleteBtn.addEventListener("click", async () => {
              if (!confirm("Biztosan törlöd a videót?")) return;
              try {
                const response = await fetch(`/api/videos/${video.id}`, {
                  method: "DELETE",
                  headers: buildAuthHeaders(),
                });
                const result = await response.json().catch(() => null);
                if (!response.ok) {
                  throw new Error((result && result.message) || "Nem sikerült törölni a videót.");
                }
                await loadVideos();
              } catch (error) {
                alert(error.message);
              }
            });
            actions.appendChild(deleteBtn);
            card.appendChild(actions);
          }

          videoGridContainer.appendChild(card);
        });
      }

      function openVideoModal(index) {
        if (!videoPlayerModal || !modalVideoPlayer || !Array.isArray(currentVideoList)) {
          return;
        }

        if (!currentVideoList.length) {
          return;
        }

        currentVideoIndex = ((index % currentVideoList.length) + currentVideoList.length) % currentVideoList.length;
        const activeVideo = currentVideoList[currentVideoIndex];
        if (!activeVideo) {
          return;
        }

        const rawTitle = activeVideo.original_name || activeVideo.filename;
        modalVideoTitle.textContent = cleanVideoTitle(rawTitle) || "Névtelen videó";
        const videoElements = videoGridContainer.querySelectorAll(".video-card video");
        const { src, has720pAvailable, prefers720p } = getPreferredVideoSource(
          activeVideo,
          currentVideoQuality
        );
        const sourceFromGrid = videoElements[currentVideoIndex]?.dataset?.src || "";
        const resolvedSource = src || sourceFromGrid;

        if (prefers720p && !has720pAvailable) {
          showClipToast("Ehhez a videóhoz nem érhető el 720p verzió.");
        }

        modalVideoPlayer.src = resolvedSource || `/uploads/${activeVideo.filename}`;
        modalVideoPlayer.load();
        modalVideoPlayer.play().catch(() => {});

        videoPlayerModal.classList.add("open");
        videoPlayerModal.setAttribute("aria-hidden", "false");
        closeVideoModalBtn?.focus({ preventScroll: true });
      }

      function closeVideoModal() {
        if (!videoPlayerModal || !modalVideoPlayer) {
          return;
        }

        modalVideoPlayer.pause();
        modalVideoPlayer.removeAttribute("src");
        modalVideoPlayer.load();
        videoPlayerModal.classList.remove("open");
        videoPlayerModal.setAttribute("aria-hidden", "true");
      }

      function showNextVideo() {
        if (!currentVideoList.length) {
          return;
        }

        const nextIndex = (currentVideoIndex + 1) % currentVideoList.length;
        openVideoModal(nextIndex);
      }

      function showPrevVideo() {
        if (!currentVideoList.length) {
          return;
        }

        const prevIndex = (currentVideoIndex - 1 + currentVideoList.length) % currentVideoList.length;
        openVideoModal(prevIndex);
      }

      function renderPagination(pagination) {
        if (!videoPagination || !pagination || pagination.totalPages <= 1) {
          return;
        }

        videoPagination.innerHTML = "";
        const { currentPage, totalPages } = pagination;

        const createButton = (pageNumber, text = null) => {
          const btn = document.createElement("button");
          btn.textContent = text || pageNumber;
          btn.classList.toggle("active", pageNumber === currentPage);
          btn.addEventListener("click", () => {
            if (pageNumber === currentPage) return;
            videoFilters.page = pageNumber;
            loadVideos();
          });
          return btn;
        };

        const windowSize = 2;
        const start = Math.max(1, currentPage - windowSize);
        const end = Math.min(totalPages, currentPage + windowSize);

        if (start > 1) {
          videoPagination.appendChild(createButton(1));
          if (start > 2) {
            const ellipsis = document.createElement("span");
            ellipsis.textContent = "...";
            videoPagination.appendChild(ellipsis);
          }
        }

        for (let page = start; page <= end; page += 1) {
          videoPagination.appendChild(createButton(page));
        }

        if (end < totalPages) {
          if (end < totalPages - 1) {
            const ellipsis = document.createElement("span");
            ellipsis.textContent = "...";
            videoPagination.appendChild(ellipsis);
          }
          videoPagination.appendChild(createButton(totalPages));
        }
      }

      if (closeVideoModalBtn) {
        closeVideoModalBtn.addEventListener("click", closeVideoModal);
      }

      if (prevVideoBtn) {
        prevVideoBtn.addEventListener("click", showPrevVideo);
      }

      if (nextVideoBtn) {
        nextVideoBtn.addEventListener("click", showNextVideo);
      }

      if (videoPlayerModal) {
        videoPlayerModal.addEventListener("click", (event) => {
          if (event.target === videoPlayerModal) {
            closeVideoModal();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (!videoPlayerModal?.classList.contains("open")) {
          return;
        }

        if (event.key === "Escape") {
          closeVideoModal();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          showNextVideo();
        } else if (event.key === "ArrowLeft") {
          event.preventDefault();
          showPrevVideo();
        }
      });

      if (videoSearchInput) {
        videoSearchInput.addEventListener("input", () => {
          videoFilters.search = videoSearchInput.value.trim();
          videoFilters.page = 1;
          if (videoSearchTimeout) {
            clearTimeout(videoSearchTimeout);
          }
          videoSearchTimeout = setTimeout(() => {
            loadVideos();
          }, 2000);
        });
      }

      if (tagFilterSelect) {
        tagFilterSelect.addEventListener("change", () => {
          videoFilters.tag = tagFilterSelect.value;
          videoFilters.page = 1;
          loadVideos();
        });
      }

      if (sortOrderSelect) {
        sortOrderSelect.addEventListener("change", () => {
          videoFilters.sort = sortOrderSelect.value === "oldest" ? "oldest" : "newest";
          localStorage.setItem(VIDEO_SORT_ORDER_KEY, videoFilters.sort);
          videoFilters.page = 1;
          loadVideos();
        });
      }

      if (videoQualitySelect) {
        videoQualitySelect.addEventListener("change", async () => {
          const selectedQuality = normalizeQualityPreference(videoQualitySelect.value);
          const previousQuality = currentVideoQuality;

          applyQualityPreference(selectedQuality);

          if (!isUserLoggedIn()) {
            return;
          }

          try {
            await saveQualityPreferenceToServer(selectedQuality);
          } catch (error) {
            console.error("Minőségi beállítás mentése sikertelen:", error);
            showClipToast(error.message || "Nem sikerült menteni a minőségi beállítást.");
            applyQualityPreference(previousQuality);
          }
        });
      }

      if (pageSizeSelect) {
        pageSizeSelect.addEventListener("change", () => {
          const selected = Number.parseInt(pageSizeSelect.value, 10);
          const allowed = [12, 24, 40, 80];
          videoFilters.limit = allowed.includes(selected) ? selected : videoFilters.limit;
          localStorage.setItem(VIDEO_PAGE_SIZE_KEY, videoFilters.limit);
          videoFilters.page = 1;
          loadVideos();
        });
      }

      if (filterResetBtn) {
        filterResetBtn.addEventListener("click", () => {
          videoFilters.page = 1;
          videoFilters.search = "";
          videoFilters.tag = "";
          videoFilters.sort = "newest";
          if (videoSearchTimeout) {
            clearTimeout(videoSearchTimeout);
            videoSearchTimeout = null;
          }
          if (videoSearchInput) videoSearchInput.value = "";
          if (tagFilterSelect) tagFilterSelect.value = "";
          if (sortOrderSelect) {
            sortOrderSelect.value = videoFilters.sort;
            localStorage.setItem(VIDEO_SORT_ORDER_KEY, videoFilters.sort);
          }
          loadVideos();
        });
      }

      async function handleCreateTag() {
        if (!newTagNameInput || !createTagStatus) return;
        const name = newTagNameInput.value.trim();
        if (!name) {
          createTagStatus.textContent = "Add meg a címke nevét.";
          return;
        }
        const color = normalizeColor(newTagColorInput?.value || DEFAULT_TAG_COLOR);
        if (tagColorButton) {
          tagColorButton.style.setProperty("--tag-color", color);
        }
        createTagStatus.textContent = "Mentés...";
        try {
          const response = await fetch("/api/tags", {
            method: "POST",
            headers: {
              ...buildAuthHeaders(),
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name, color }),
          });
          const result = await response.json().catch(() => null);
          if (!response.ok) {
            throw new Error((result && result.message) || "Nem sikerült létrehozni a címkét.");
          }
          newTagNameInput.value = "";
          if (newTagColorInput) {
            newTagColorInput.value = DEFAULT_TAG_COLOR;
          }
          if (tagColorButton) {
            tagColorButton.style.setProperty("--tag-color", DEFAULT_TAG_COLOR);
          }
          createTagStatus.textContent = "Címke létrehozva.";
          await fetchTags();
        } catch (error) {
          createTagStatus.textContent = error.message;
        }
      }

      async function handleDeleteTag() {
        if (!createTagStatus) return;
        const selectedOption = globalTagSelect?.selectedOptions?.[0];
        const tagId = Number.parseInt(selectedOption?.value, 10);
        if (!tagId) {
          createTagStatus.textContent = "Válassz ki egy címkét a törléshez.";
          return;
        }

        createTagStatus.textContent = "Címke törlése...";
        try {
          const response = await fetch(`/api/tags/${tagId}`, {
            method: "DELETE",
            headers: buildAuthHeaders(),
          });
          const result = await response.json().catch(() => null);
          if (!response.ok) {
            throw new Error((result && result.message) || "Nem sikerült törölni a címkét.");
          }
          createTagStatus.textContent = "Címke törölve.";
          if (globalTagSelect) {
            globalTagSelect.value = "";
          }
          await fetchTags();
        } catch (error) {
          createTagStatus.textContent = error.message;
        }
      }

      if (newTagColorInput && tagColorButton) {
        const updateTagColorPreview = () => {
          const color = normalizeColor(newTagColorInput.value || DEFAULT_TAG_COLOR);
          tagColorButton.style.setProperty("--tag-color", color);
        };

        tagColorButton.addEventListener("click", () => newTagColorInput.click());
        newTagColorInput.addEventListener("input", updateTagColorPreview);
        updateTagColorPreview();
      }

      if (createTagButton) {
        createTagButton.addEventListener("click", handleCreateTag);
      }

      if (deleteTagButton) {
        deleteTagButton.addEventListener("click", handleDeleteTag);
      }

      function resetUploadModal() {
        uploadQueue = [];
        fileSignatures.clear();
        uploadedVideoIds = [];
        isUploadCancelled = false;
        isUploading = false;
        currentUploadXhr = null;
        renderUploadQueue();
        updateUploadSummary();
        if (uploadBtn) {
          uploadBtn.disabled = true;
        }
        if (cancelUploadBtn) {
          cancelUploadBtn.disabled = false;
        }
        if (uploadStatus) {
          uploadStatus.textContent = "";
        }
        resetUploadProgress();
        if (uploadToast) {
          uploadToast.classList.remove("upload-toast--visible");
          uploadToast.textContent = "";
        }
        if (fileInput) {
          fileInput.value = "";
        }
        if (dropZone) {
          dropZone.classList.remove("drag-over");
        }
        if (globalTagSelect) {
          globalTagSelect.selectedIndex = -1;
        }
        if (createTagStatus) {
          createTagStatus.textContent = "";
        }
        if (newTagColorInput) {
          newTagColorInput.value = DEFAULT_TAG_COLOR;
        }
        if (tagColorButton) {
          tagColorButton.style.setProperty("--tag-color", DEFAULT_TAG_COLOR);
        }
      }

      function openUploadModal() {
        if (uploadModal) {
          uploadModal.style.display = "flex";
          uploadModal.classList.add("modal-overlay--visible");
        }
        fetchTags();
        resetUploadModal();
      }

      function closeUploadModal() {
        if (uploadModal) {
          uploadModal.classList.remove("modal-overlay--visible");
          uploadModal.style.display = "none";
        }
        resetUploadModal();
      }

      async function handleFileSelection(files) {
        const normalized = Array.isArray(files)
          ? files.filter(Boolean)
          : Array.from(files || []).filter(Boolean);

        if (!normalized.length) {
          return;
        }

        const remainingSlots = MAX_UPLOAD_FILES - uploadQueue.length;
        if (remainingSlots <= 0) {
          showUploadToast(`Egyszerre legfeljebb ${MAX_UPLOAD_FILES} fájl tölthető fel.`);
          return;
        }

        const limitedFiles = normalized.slice(0, remainingSlots);
        if (limitedFiles.length < normalized.length) {
          showUploadToast(`Csak az első ${remainingSlots} fájl került a sorba (maximum ${MAX_UPLOAD_FILES} egyszerre).`);
        }

        const globalTags = getSelectValues(globalTagSelect);
        for (const file of limitedFiles) {
          const signature = getFileSignature(file);
          if (fileSignatures.has(signature)) {
            showUploadToast("Ez a videó már a listán van!");
            continue;
          }

          fileSignatures.add(signature);
          let thumbnail = null;
          try {
            thumbnail = await generateVideoThumbnail(file);
          } catch (error) {
            console.warn("Nem sikerült indexképet generálni:", error);
          }

          uploadQueue.push({
            file,
            signature,
            displayName: file.name,
            tags: [...globalTags],
            thumbnail,
          });
        }

        renderUploadQueue();
        updateUploadSummary();
        if (uploadBtn) {
          uploadBtn.disabled = uploadQueue.length === 0;
        }
        if (uploadStatus) {
          uploadStatus.textContent = "";
        }
      }

      if (showUploadModalBtn && uploadModal) {
        showUploadModalBtn.addEventListener("click", () => {
          if (!isUserLoggedIn()) {
            alert("A feltöltéshez be kell jelentkezned.");
            return;
          }
          if (!hasClipAccess()) {
            alert("A klipekhez való hozzáféréshez külön engedély szükséges.");
            updateClipAccessUI();
            return;
          }
          openUploadModal();
        });
      }

      if (closeUploadModalBtn) {
        closeUploadModalBtn.addEventListener("click", closeUploadModal);
      }

      if (uploadModal) {
        uploadModal.addEventListener("click", (event) => {
          if (event.target === uploadModal) {
            closeUploadModal();
          }
        });
      }

      if (dropZone && fileInput) {
        dropZone.addEventListener("click", () => fileInput.click());

        dropZone.addEventListener("dragover", (event) => {
          event.preventDefault();
          dropZone.classList.add("drag-over");
        });

        ["dragleave", "dragend"].forEach((eventName) => {
          dropZone.addEventListener(eventName, (event) => {
            event.preventDefault();
            dropZone.classList.remove("drag-over");
          });
        });

        dropZone.addEventListener("drop", (event) => {
          event.preventDefault();
          dropZone.classList.remove("drag-over");
          const files = event.dataTransfer?.files;
          if (files && files.length > 0) {
            handleFileSelection(files);
          }
        });
      }

      if (addFilesBtn && fileInput) {
        addFilesBtn.addEventListener("click", () => fileInput.click());
      }

      if (globalTagSelect) {
        globalTagSelect.addEventListener("change", () => {
          const selected = getSelectValues(globalTagSelect);
          uploadQueue = uploadQueue.map((item) => ({ ...item, tags: [...selected] }));
          renderUploadQueue();
        });
      }

      if (fileInput) {
        fileInput.addEventListener("change", (event) => {
          const files = event.target.files;
          if (files && files.length > 0) {
            handleFileSelection(files);
          } else {
            resetUploadModal();
          }
        });
      }

      if (cancelUploadBtn) {
        cancelUploadBtn.addEventListener("click", () => {
          if (!isUploading) {
            closeUploadModal();
            return;
          }

          isUploadCancelled = true;
          cancelUploadBtn.disabled = true;
          if (uploadStatus) {
            uploadStatus.textContent = "Feltöltés megszakítása folyamatban...";
          }

          if (currentUploadXhr) {
            currentUploadXhr.abort();
          }
        });
      }

      if (uploadBtn) {
        uploadBtn.addEventListener("click", async () => {
          if (!isUserLoggedIn()) {
            alert("A feltöltéshez be kell jelentkezned.");
            return;
          }

          if (!uploadQueue.length) {
            alert("Válassz ki legalább egy videófájlt a feltöltéshez.");
            return;
          }

          if (isUploading) {
            return;
          }

          isUploading = true;
          isUploadCancelled = false;
          uploadedVideoIds = [];
          uploadBtn.disabled = true;
          if (cancelUploadBtn) {
            cancelUploadBtn.disabled = false;
          }
          if (uploadStatus) {
            uploadStatus.textContent = "Feltöltés folyamatban...";
          }

          const totalUploadBytes = uploadQueue.reduce((sum, item) => sum + (item.file?.size || 0), 0);
          const totalFiles = uploadQueue.length;
          const uploadStartTime = performance.now();
          let uploadedBytesSoFar = 0;

          updateUploadProgressUI({
            uploadedBytes: 0,
            totalBytes: totalUploadBytes,
            completedFiles: 0,
            totalFiles,
            etaSeconds: Infinity,
          });

          const uploadSingleFile = (item, index) =>
            new Promise((resolve, reject) => {
              const formData = new FormData();
              const metadata = [
                {
                  name: item.displayName || item.file.name,
                  tags: item.tags || [],
                  signature: item.signature,
                },
              ];

              formData.append("videos", item.file);
              formData.append("metadata", JSON.stringify(metadata));

              const xhr = new XMLHttpRequest();
              xhr.open("POST", "/upload");
              xhr.responseType = "json";
              currentUploadXhr = xhr;

              const headers = buildAuthHeaders();
              if (headers && typeof headers === "object") {
                Object.entries(headers).forEach(([key, value]) => {
                  if (value) {
                    xhr.setRequestHeader(key, value);
                  }
                });
              }

              xhr.addEventListener("abort", () => {
                reject(new Error(UPLOAD_ABORT_MESSAGE));
              });

              xhr.addEventListener("loadend", () => {
                if (currentUploadXhr === xhr) {
                  currentUploadXhr = null;
                }
              });

              xhr.upload.addEventListener("progress", (event) => {
                const currentFileUploaded = event.loaded || 0;
                const uploadedBytes = Math.min(uploadedBytesSoFar + currentFileUploaded, totalUploadBytes);
                const elapsedSeconds = Math.max((performance.now() - uploadStartTime) / 1000, 0.001);
                const speed = uploadedBytes / elapsedSeconds;
                const remainingBytes = Math.max(totalUploadBytes - uploadedBytes, 0);
                const etaSeconds = speed > 0 ? remainingBytes / speed : Infinity;

                let completedFiles = 0;
                let remainingForCount = uploadedBytes;
                for (const queuedItem of uploadQueue) {
                  const fileSize = queuedItem.file?.size || 0;
                  if (fileSize === 0) {
                    completedFiles += 1;
                    continue;
                  }
                  if (remainingForCount >= fileSize) {
                    completedFiles += 1;
                    remainingForCount -= fileSize;
                  } else {
                    break;
                  }
                }

                if (uploadStatus) {
                  uploadStatus.textContent = `Feltöltés: ${index + 1} / ${totalFiles} - "${
                    item.displayName || item.file.name
                  }"...`;
                }

                updateUploadProgressUI({
                  uploadedBytes,
                  totalBytes: totalUploadBytes,
                  completedFiles,
                  totalFiles,
                  etaSeconds,
                });
              });

              xhr.addEventListener("load", () => {
                const result = xhr.response;
                if (xhr.status >= 200 && xhr.status < 300) {
                  const finishedBytes = uploadedBytesSoFar + (item.file?.size || 0);
                  const uploadedBytes = Math.min(finishedBytes, totalUploadBytes);
                  const elapsedSeconds = Math.max((performance.now() - uploadStartTime) / 1000, 0.001);
                  const speed = uploadedBytes / elapsedSeconds;
                  const remainingBytes = Math.max(totalUploadBytes - uploadedBytes, 0);
                  const etaSeconds = speed > 0 ? remainingBytes / speed : Infinity;

                  const completedFiles = index + 1;

                  updateUploadProgressUI({
                    uploadedBytes,
                    totalBytes: totalUploadBytes,
                    completedFiles,
                    totalFiles,
                    etaSeconds,
                  });
                  uploadedBytesSoFar = uploadedBytes;
                  const idsFromResponse = Array.isArray(result?.videoIds)
                    ? result.videoIds.filter((id) => Number.isFinite(Number(id)))
                    : [];
                  if (idsFromResponse.length) {
                    uploadedVideoIds.push(...idsFromResponse);
                  }
                  resolve(result);
                } else {
                  const message = (result && result.message) || "Nem sikerült feltölteni a videót.";
                  reject(new Error(message));
                }
              });

              xhr.addEventListener("error", () => {
                reject(new Error("Hálózati hiba történt a feltöltés során."));
              });

              xhr.send(formData);
            });

          try {
            for (const [index, item] of uploadQueue.entries()) {
              await uploadSingleFile(item, index);
            }

            if (uploadStatus) {
              uploadStatus.textContent = "Videók sikeresen feltöltve.";
            }
            await loadVideos();
            setTimeout(() => {
              closeUploadModal();
            }, 800);
          } catch (error) {
            console.error("Videó feltöltési hiba:", error);
            if (isUploadCancelled || error?.message === UPLOAD_ABORT_MESSAGE) {
              if (uploadStatus) {
                uploadStatus.textContent = "Feltöltés megszakítva, videók törlése...";
              }
              try {
                if (uploadedVideoIds.length) {
                  await rollbackUploadedVideos([...new Set(uploadedVideoIds)]);
                  if (uploadStatus) {
                    uploadStatus.textContent = "Feltöltés megszakítva, már feltöltött videók törölve.";
                  }
                } else if (uploadStatus) {
                  uploadStatus.textContent = "Feltöltés megszakítva.";
                }
              } catch (rollbackError) {
                console.error("Visszavonási hiba:", rollbackError);
                if (uploadStatus) {
                  uploadStatus.textContent =
                    rollbackError.message || "Nem sikerült törölni a feltöltött videókat.";
                }
              } finally {
                uploadQueue = [];
                fileSignatures.clear();
                renderUploadQueue();
                updateUploadSummary();
                if (fileInput) {
                  fileInput.value = "";
                }
                resetUploadProgress();
              }
            } else if (uploadStatus) {
              uploadStatus.textContent = error.message || "Nem sikerült feltölteni a videót.";
            }
          } finally {
            if (uploadBtn) {
              uploadBtn.disabled = uploadQueue.length === 0;
            }
            if (cancelUploadBtn) {
              cancelUploadBtn.disabled = false;
            }
            isUploading = false;
            isUploadCancelled = false;
            currentUploadXhr = null;
            uploadedVideoIds = [];
          }
        });
      }

      function showSection(target, shouldPushState = true) {
        const navLinks = getAccessibleNavLinks();
        const sections = document.querySelectorAll("main section");
        const availableTargets = new Set(navLinks.map((link) => link.dataset.section));

        availableTargets.add("profile");

        if (!availableTargets.has(target)) {
          target = "home";
        }

        document.querySelectorAll("nav a").forEach((link) => {
          const requiresAdmin = link.dataset.requiresAdmin === "true";
          const requiresTransfer = link.dataset.requiresTransfer === "true";
          const isActive = link.dataset.section === target;

          if (
            (requiresAdmin && !isAdminUser()) ||
            (requiresTransfer && !hasFileTransferPermission())
          ) {
            link.classList.remove("active");
            return;
          }

          link.classList.toggle("active", isActive);
        });

        sections.forEach((sec) => {
          const requiresAdmin = ADMIN_ONLY_SECTIONS.has(sec.id);

          if (sec.id === target && (!requiresAdmin || isAdminUser())) {
            sec.classList.add("active");
          } else {
            sec.classList.remove("active");
          }
        });

        if (target === "klipek") {
          updateClipAccessUI();
          if (hasClipAccess()) {
            fetchTags();
            loadVideos();
          }
        }

        if (target === "szavazas") {
          refreshPollsIfVisible();
        }

        if (target === "programok") {
          loadPrograms();
        }

        if (shouldPushState) {
          history.pushState(null, "", `#${target}`);
        }
      }

      document.querySelectorAll("nav a").forEach((link) => {
        link.addEventListener("click", (e) => {
          const requiresAdmin = link.dataset.requiresAdmin === "true";
          const requiresTransfer = link.dataset.requiresTransfer === "true";

          if (requiresAdmin && !isAdminUser()) {
            e.preventDefault();
            return;
          }

          if (requiresTransfer && !hasFileTransferPermission()) {
            e.preventDefault();
            return;
          }

          e.preventDefault();
          showSection(link.dataset.section);
        });
      });

      // Oldal betöltésekor a hash alapján nyitjuk meg a megfelelő szekciót
      window.addEventListener("load", () => {
        const hash = location.hash.replace("#", "") || "home";
        showSection(hash, false);
      });

    </script>

  <script src="HOI4-Porgonc/script.js"></script>
  </body>
</html>
